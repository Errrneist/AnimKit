from pymel.core import *
import maya.mel as mel
import maya.cmds as cmds
import random as r
import shutil, subprocess, sys, getpass, time, os, platform
from mtoa.cmds.arnoldRender import arnoldRender

# Version Info
version = "2.0.0"
update = "July 18, 2020"
new = "Zoetrope 2.0 brings bug fixes as well as new features like automatic padding detection, frame range prompt, etc."

class TimelineProperties:
    @property
    def START(self):
        return playbackOptions(q=1, animationStartTime=1)
    @property
    def END(self):
        return playbackOptions(q=1, animationEndTime=1)
    @property
    def INNER_START(self):
        return playbackOptions(q=1, minTime=1)
    @property
    def INNER_END(self):
        return playbackOptions(q=1, maxTime=1)

def get_resolution_settings(attr):
    return cmds.getAttr("%s.%s"%("defaultResolution", attr))
    
def render_frame(width, height, frame, file_format="tif", render_layer = "defaultRenderLayer", image_padding = 4):
    # Render the frame
    # Known bug: The result file generated by arnoldRender() adds a _1_ to the file name
    file_dir = (sceneName().parent + "\\renders\\" + render_layer).replace('\\', '/')
    prepend = os.path.basename(sceneName()).split('.')[0]
    cmds.setAttr("defaultArnoldDriver.ai_translator", file_format, type="string")
    cmds.setAttr("defaultArnoldDriver.pre", file_dir + "\\" + prepend, type="string")
    cmds.setAttr("render_camShape.mask", 1)
    arnoldRender(width, height, True, True,'render_cam', ' -layer ' + render_layer)

    # Fix the weird _1_ bug
    bug = "_1_"  # idk whyyyy does this happen 
    prefix_image_dir = file_dir + "\\" + prepend + bug + "{:0>4d}".format(frame) + "." + file_format
    postfix_image_dir = file_dir + "\\" + prepend + "_" + "{:0>4d}".format(frame) + "." + file_format
    print("[Zoetrope] Prefix Image Directory: " + prefix_image_dir)
    print("[Zoetrope] Postfix Image Directory: " + postfix_image_dir)
    os.rename(prefix_image_dir,postfix_image_dir)
    


def batch_render(renderStart, renderEnd, width = get_resolution_settings("width"), height = get_resolution_settings("height"), target_format = "tif", useDefaultRenderLayer = False):
    # Prompt user to check render range.
    msg = "Will render from frame " + str(renderStart) + " to frame " + str(renderEnd) + ". Are you sure?"
    prompt_start = cmds.confirmDialog( title='Confirm Render', message=msg, button=['Yes','No'], defaultButton='Yes', cancelButton='No', dismissString='No' )

    if prompt_start != "No":
        # Get list of render layers.
        render_layers = {cmds.getAttr( i + ".displayOrder") : i for i in cmds.ls(type='renderLayer')}
        render_layers.pop(0)  # Gets rid of "defaultRenderLayer"

        # Set only layer to default current layer.
        if useDefaultRenderLayer: render_layers = {0: "defaultRenderLayer"}

        # Batch Render.
        for index in render_layers:
            layer = render_layers[index]
            print("[ZOETROPE]: Current Render Layer: ", layer)
            for frame in range(renderStart, renderEnd + 1):
                cmds.currentTime(frame)
                render_frame(width, height, frame, target_format, layer)

        # Exit message.
        cmds.confirmDialog(title='Animkit Zoetrope: Task Finished.', 
        message='Task finished. Successfully batch rendered all requested layers into target directory.', 
        button=['I got it!'], defaultButton='I got it!', dismissString='I got it!')

# MP4 Encoder Section

def mp4_encoder(renders_dir, renders_prefix, render_layer, frame_rate = 24 , frame_padding = 4, 
                  image_format = "tif", target_format = "mp4"):
    
    image_sequence_path = renders_dir + "/renders/" + render_layer + "/" + renders_prefix + "_%0" + str(frame_padding) + "d." + image_format
    video_path = renders_dir + "/renders/" + render_layer + "/" + renders_prefix + "." + target_format
    
    print("[Zoetrope] Image sequence path: " + image_sequence_path)
    print("[Zoetrope] Video target path: " + video_path)
    
    subprocess.call(["ffmpeg", "-framerate", str(frame_rate), "-i", 
                     image_sequence_path, video_path], shell=True)
    
    print("[Zoetrope] Successfully encoded the image sequence to video of " + target_format + " format.")

def path_leaf(path):
    head, tail = ntpath.split(path)
    return tail or ntpath.basename(head)

# Zoetrope API

def render_w_padding(self):
    TIMELINE = TimelineProperties()
    batch_render(renderStart = int(TIMELINE.START), renderEnd = int(TIMELINE.END))

def render_nopadding(self):
    TIMELINE = TimelineProperties()
    batch_render(renderStart = int(TIMELINE.INNER_START), renderEnd = int(TIMELINE.INNER_END))

def render_default_w_padding(self):
    TIMELINE = TimelineProperties()
    batch_render(renderStart = int(TIMELINE.START), renderEnd = int(TIMELINE.END), useDefaultRenderLayer = True)

def render_default_nopadding(self):
    TIMELINE = TimelineProperties()
    batch_render(renderStart = int(TIMELINE.INNER_START), renderEnd = int(TIMELINE.INNER_END), useDefaultRenderLayer = True)

def render_one_frame(self):
    TIMELINE = TimelineProperties()
    render_frame(width = get_resolution_settings("width"), height = get_resolution_settings("height"), frame=TIMELINE.INNER_START, file_format="png")

def smart_convert_all_renders_compressed(self):
    scene_path = cmds.file(location=True, query=True) 
    current_dir = os.path.dirname(scene_path)
    list_render_subfolders_with_paths = list({cmds.getAttr( i + ".displayOrder") : i for i in cmds.ls(type='renderLayer')}.values())
    for render_layer_folder in list_render_subfolders_with_paths:
        print("[Zoetrope] Current compositing render layer: " + render_layer_folder)
        seq_folder = current_dir + "/renders/" + render_layer_folder
        print("[Zoetrope] Current Sequence Folder: " + seq_folder)
        # Sample a file and get extension of the files in the render folder
        ext = os.path.splitext([f for f in os.listdir(seq_folder) if os.path.isfile(os.path.join(seq_folder, f))][0])[1].replace('.', '')

        mp4_encoder(renders_dir = current_dir, renders_prefix = os.path.basename(sceneName().split('.')[0]), render_layer = render_layer_folder, image_format = ext, target_format = "mp4")

def smart_convert_all_renders_lossless(self):
    scene_path = cmds.file(location=True, query=True) 
    current_dir = os.path.dirname(scene_path)
    list_render_subfolders_with_paths = list({cmds.getAttr( i + ".displayOrder") : i for i in cmds.ls(type='renderLayer')}.values())
    for render_layer_folder in list_render_subfolders_with_paths:
        print("[Zoetrope] Current compositing render layer: " + render_layer_folder)
        seq_folder = current_dir + "/renders/" + render_layer_folder
        print("[Zoetrope] Current Sequence Folder: " + seq_folder)
        # Sample a file and get extension of the files in the render folder
        ext = os.path.splitext([f for f in os.listdir(seq_folder) if os.path.isfile(os.path.join(seq_folder, f))][0])[1].replace('.', '')

        mp4_encoder(renders_dir = current_dir, renders_prefix = os.path.basename(sceneName().split('.')[0]), render_layer = render_layer_folder, image_format = ext, target_format = "avi")

def manual_convert_renders_compressed(self):
    result = cmds.promptDialog(
		title='Manual Conversion',
		message='Enter Path:',
		button=['OK', 'Cancel'],
		defaultButton='OK',
		cancelButton='Cancel',
		dismissString='Cancel')

    if result == 'OK':
        seq_folder = cmds.promptDialog(query=True, text=True)

        ext = os.path.splitext([f for f in os.listdir(seq_folder) if os.path.isfile(os.path.join(seq_folder, f))][0])[1].replace('.', '')
        
        mp4_encoder(renders_dir = current_dir, renders_prefix = os.path.basename(sceneName().split('.')[0]), render_layer = render_layer_folder, image_format = ext, target_format = "mp4")

    