from pymel.core import *
import maya.mel as mel
import maya.cmds as cmds
import random as r
import shutil, subprocess, sys, getpass, time, os, platform
from mtoa.cmds.arnoldRender import arnoldRender

# Version Info
VERSION = "2.1.0"
UPDATE = "July 27, 2020"
NEW = "Zoetrope 2.1 brings bug fixes as well as new features like automatic padding detection, frame range prompt, etc."


# Current Timeline Class
class TimelineProperties:
    @property
    def START(self):
        return playbackOptions(q=1, animationStartTime=1)
    @property
    def END(self):
        return playbackOptions(q=1, animationEndTime=1)
    @property
    def INNER_START(self):
        return playbackOptions(q=1, minTime=1)
    @property
    def INNER_END(self):
        return playbackOptions(q=1, maxTime=1)

# Getter Methods
def get_resolution_settings(attr):
    '''
    attr = "width" or "height".
    Returns an int of the current width or height of the current render settings.
    '''
    return cmds.getAttr("%s.%s"%("defaultResolution", attr))

def get_padding():
    '''
    Returns an int of the current frame padding in the render settings.
    '''
    return cmds.getAttr("defaultRenderGlobals.extensionPadding")

def get_frame_rate():
    '''
    Returns an int of the framerate of the current scene.
    '''
    # Framerate Info
    FRAMERATE_INFO = {"game":15, "film":24, "pal":25, "ntsc":30, "show":48, "palf":50, "ntscf":60}
    current_time = cmds.currentUnit(query=True, time=True)
    return FRAMERATE_INFO.get(current_time)
    
# Render Functions
def render_frame(width, height, frame, file_format="tif", render_layer = "defaultRenderLayer", image_padding = get_padding()):
    '''
    Render the selected frame into scene_folder/renders/render_layer/ folder.
    '''
    # Render the frame
    frame = int(frame)

    # Known bug: The result file generated by arnoldRender() adds a _1_ to the file name
    file_dir = (sceneName().parent + "\\renders\\" + render_layer).replace('\\', '/')
    prepend = os.path.basename(sceneName()).split('.')[0]
    cmds.setAttr("defaultArnoldDriver.ai_translator", file_format, type="string")
    cmds.setAttr("defaultArnoldDriver.pre", file_dir + "\\" + prepend, type="string")
    cmds.setAttr("render_camShape.mask", 1)
    arnoldRender(width, height, True, True,'render_cam', ' -layer ' + render_layer)

    # Fix the weird _1_ bug
    bug = "_1_"  # idk whyyyy does this happen 
    prefix_image_dir = file_dir + "\\" + prepend + bug + "{:0>4d}".format(frame) + "." + file_format
    postfix_image_dir = file_dir + "\\" + prepend + "_" + "{:0>4d}".format(frame) + "." + file_format
    print("[Zoetrope] Frame Renderer - Prefix Image Directory: " + prefix_image_dir)
    print("[Zoetrope] Frame Renderer - Postfix Image Directory: " + postfix_image_dir)
    os.rename(prefix_image_dir,postfix_image_dir)
    


def batch_render(renderStart, renderEnd, width = get_resolution_settings("width"), height = get_resolution_settings("height"), target_format = "tif", useDefaultRenderLayer = False):
    '''
    Calls render_frame and perform batch rendering.
    '''
    # Prompt user to check render range.
    msg = "Will render from frame " + str(renderStart) + " to frame " + str(renderEnd) + ". Are you sure?"
    prompt_start = cmds.confirmDialog( title='Confirm Render', message=msg, button=['Yes','No'], defaultButton='Yes', cancelButton='No', dismissString='No' )

    # Actual Batch Render
    if prompt_start != "No":
        # Get list of render layers.
        render_layers = {cmds.getAttr( i + ".displayOrder") : i for i in cmds.ls(type='renderLayer')}
        render_layers.pop(0)  # Gets rid of "defaultRenderLayer"

        # Set only layer to default current layer.
        if useDefaultRenderLayer: render_layers = {0: "defaultRenderLayer"}

        # Batch Render.
        for index in render_layers:
            layer = render_layers[index]
            print("[ZOETROPE] Batch Render - Current Render Layer: ", layer)
            for frame in range(renderStart, renderEnd + 1):
                cmds.currentTime(frame)
                render_frame(width, height, frame, target_format, layer)

        # Exit message.
        cmds.confirmDialog(title='Animkit Zoetrope: Task Finished.', 
        message='Task finished. Successfully rendered all requested layers into target directory.', 
        button=['I got it!'], defaultButton='I got it!', dismissString='I got it!')

# Video Encoder

def video_encoder(seq_folder, renders_prefix, image_format, target_format, frame_rate = get_frame_rate(), frame_padding = get_padding()):
    '''
    Encodes image sequence into respective file format.
    '''
    
    image_sequence_path = seq_folder + renders_prefix + "_%0" + str(frame_padding) + "d." + image_format
    video_path = seq_folder + renders_prefix + "." + target_format
    
    print("[Zoetrope] Video Encoder - Image sequence path: " + image_sequence_path)
    print("[Zoetrope] Video Encoder - Video target path: " + video_path)
    
    subprocess.call(["ffmpeg", "-framerate", str(frame_rate), "-i", image_sequence_path, video_path], shell=True)
    
    print("[Zoetrope] Video Encoder - Successfully encoded the image sequence to video of " + target_format + " format.")

def assemble_sequence_folder(seq_folder, rendersPrefix = os.path.basename(sceneName().split('.')[0]), targetFormat = "mp4"):
    print("[Zoetrope] Sequence Folder Assembler - Current: " + seq_folder) 

    # Checking if the list is empty or not 
    if len(os.listdir(seq_folder)) == 0: 
        print("[Zoetrope] Video Converter - Empty directory at: " + seq_folder) 
    else: 
        # Sample a file and get extension of the files in the render folder
        isPicture = False
        ext = ""

        while(not isPicture):
            file_list = [f for f in os.listdir(seq_folder) if os.path.isfile(os.path.join(seq_folder, f))]
            for counter in range(len(file_list)):
                ext = os.path.splitext(file_list[counter])[1].replace('.', '') 
                format_list = ["png", "jpeg", "jpg", "tif"]
                if ext in format_list: isPicture = True

        if(isPicture):
            video_encoder(seq_folder = seq_folder, renders_prefix = rendersPrefix, image_format = ext, target_format = targetFormat)
        else:
            print("[Zoetrope] Video Converter - No image found at: " + seq_folder)

def video_converter(targetFormat):
    '''
    Calls video_encoder and convert all render layers into respective file format. 
    '''
    scene_path = cmds.file(location=True, query=True) 
    list_render_subfolders_with_paths = [x for x in os.listdir(current_dir + "/renders/") if os.path.isdir(current_dir + "/renders/" + x)]
    print("[Zoetrope] Video Converter - All avaliable render layers: " + str(list_render_subfolders_with_paths))

    for render_layer_folder in list_render_subfolders_with_paths:
        print("[Zoetrope] Video Converter - Current compositing render layer: " + render_layer_folder)
        current_dir = os.path.dirname(scene_path)
        # seq_folder = current_dir + "/renders/" + render_layer_folder
        seq_folder = current_dir + "/renders/" + render_layer_folder + "/"
        print("[Zoetrope] Video Converter - Current Sequence Folder: " + mainImagePath)
        assemble_sequence_folder(seq_folder = seq_folder, targetFormat = targetFormat)

def manual_convert_renders(targetFormat):
    '''
    Manually convert image sequence in a given path into a video.
    '''
    result = cmds.promptDialog(
		title='Manual Conversion',
		message='Enter Path:',
		button=['OK', 'Cancel'],
		defaultButton='OK',
		cancelButton='Cancel',
		dismissString='Cancel')

    if result == 'OK':
        seq_folder = cmds.promptDialog(query=True, text=True)
        dir_list = os.listdir(seq_folder) # Getting the list of directories 
        # Checking if the list is empty or not 
        if len(os.listdir(seq_folder)) == 0: 
            print("[Zoetrope] Video Converter - Empty directory at: " + seq_folder) 
        else: 
            # Sample a file and get extension of the files in the render folder
            isPicture = False

            while(isPicture == False):
                ext = os.path.splitext([f for f in os.listdir(seq_folder) if os.path.isfile(os.path.join(seq_folder, f))][0])[1].replace('.', '') 
                format_list = ["png", "jpeg", "jpg", "tif"]
                if ext in format_list: isPicture = True

            if(isPicture):
                video_encoder(renders_dir = current_dir, renders_prefix = os.path.basename(sceneName().split('.')[0]), render_layer = render_layer_folder, image_format = ext, target_format = targetFormat)

# Zoetrope API

def render_w_padding(self):
    TIMELINE = TimelineProperties()
    batch_render(renderStart = int(TIMELINE.START), renderEnd = int(TIMELINE.END))

def render_nopadding(self):
    TIMELINE = TimelineProperties()
    batch_render(renderStart = int(TIMELINE.INNER_START), renderEnd = int(TIMELINE.INNER_END))

def render_default_w_padding(self):
    TIMELINE = TimelineProperties()
    batch_render(renderStart = int(TIMELINE.START), renderEnd = int(TIMELINE.END), useDefaultRenderLayer = True)

def render_default_nopadding(self):
    TIMELINE = TimelineProperties()
    batch_render(renderStart = int(TIMELINE.INNER_START), renderEnd = int(TIMELINE.INNER_END), useDefaultRenderLayer = True)

def render_one_frame_png(self):
    render_frame(width = get_resolution_settings("width"), height = get_resolution_settings("height"), frame=cmds.currentTime(query=True), file_format="png")

def render_one_frame_tif(self):
    render_frame(width = get_resolution_settings("width"), height = get_resolution_settings("height"), frame=cmds.currentTime(query=True), file_format="tif")

def smart_convert_all_renders_compressed(self):
    video_converter(targetFormat = "mp4")

def smart_convert_all_renders_lossless(self):
    video_converter(targetFormat = "avi")

def manual_convert_renders_compressed(self):
    manual_convert_renders(targetFormat = "mp4")

def manual_convert_renders_lossless(self):
    manual_convert_renders(targetFormat = "avi")

    