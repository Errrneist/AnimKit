import re
from pymel import *
from scene_manager.methods import *
import pymel.core.runtime as rt
import os
import random

#meta methods
def fromNetworkToObject(node):
		'''
			turns the networkNode into the correct MetaNode object
		'''
		metaType = node.metaType.get()
		if metaType == 'FKChain':
			return FKChain('','','','',node = node)
		elif metaType == 'COGChain':
			return COGChain('','','','',node = node)
		elif metaType == 'SDKComponent':
			return SDKComponent('','','',node = node)
		elif metaType == 'SDK':
			return SDK('','','',node = node)
		elif metaType == 'ReverseChain':
			return ReverseChain('','','','',node = node)
		elif metaType == 'AdditionalTwist':
			return AdditionalTwist('','','','','',node = node)
		elif metaType == 'SingleIKChain':
			return SingleIKChain('','','','',node = node)
		elif metaType == 'FKIKSplineChain':
			return FKIKSplineChain('','','','',node = node)
		elif metaType == 'IKLips':
			return IKLips('','','','','','','','',node = node)
		elif metaType == 'FKIKChain':
			return FKIKChain('','','','',node = node)
		elif metaType == 'AdvancedFoot':
			return AdvancedFoot('','','','','','','','',node = node)
		elif metaType == 'EyeAimComponent':
			return EyeAimComponent('','','','','','',node = node)
		elif metaType == 'DynamicChain':
			return DynamicChain('','','','',node = node)
		elif metaType == 'StretchyJointChain':
			return StretchyJointChain('','','','','','', node = node)
		elif metaType == 'FKIKArm':
			return FKIKArm('','','','', node = node)
		elif metaType == 'FKIKLeg':
			return FKIKLeg('','','','','','','','', node = node)
		elif metaType == 'FKIKSpine':
			return FKIKSpine('','','','', node = node)
		elif metaType == 'Manager':
			return Manager(node = node)
		elif metaType == 'LightGroup':
			return LightGroup('', node = node)
		elif metaType == 'GeometryGroup':
			return GeometryGroup('', node = node)
		elif metaType == 'GeometryResGroup':
			return GeometryResGroup('', node = node)
		elif metaType == 'CharacterRig':
			return CharacterRig('','','', node = node)
		elif metaType == 'MultiConstraint':
			return MultiConstraint('','', node = node)
		elif metaType == 'Evil':
			return Evil('', node = node)
		else:
			raise Exception("fromNetworkToObject:metaNode of metaType, %s, either isn't a metaNode or not added to the fromNetworkToObject method"%metaType)

def connectToMeta(child, parent, attrName):
	'''
	connects parent.attrName to child.metaParent
	
	child:
		child node
		
	parent:
		should be a MetaNode 
		
	attrName:
		the name of the parents attr connecting to, attr that wants reference to child
	'''
	if(not objExists(child)):
		printError("connectToMeta:" + child+ "doesn't exist")
	if(not objExists(parent)):	
		printError("connectToMeta: "+parent+" doesn't exist")
	
	addMetaParentAttr(child)
	parent = PyNode(parent)
	
	
	index = attrName.find('[')
	if not index == -1:
		attrName = attrName.split("[")[0]
			
	if not parent.hasAttr(attrName) and index == -1:
		parent.addAttr(attrName, dt = "string")
		PyNode(child).metaParent >> parent.attr(attrName)
	elif parent.hasAttr(attrName) and index == -1 and not parent.attr(attrName).isMulti():
		PyNode(child).metaParent >> parent.attr(attrName)
	else:
		if not parent.hasAttr(attrName):
			parent.addAttr(attrName, dt = "string", m = 1)
		array = parent.attr(attrName).getArrayIndices()
		done = 0
		inc = -1
		while not done:
			inc +=1
			if not inc in array:
				done = 1
		PyNode(child).metaParent >> parent.attr(attrName).elementByLogicalIndex(inc)

def connectChainToMeta(objList, parent, attrName):
	'''
	connects all the objects to a multi string attr attrName
	
	objList:
		list of child objects to connect to meta
		
	parent:
		parent meta node
		
	attrName:
		name of parents attribute which will have easy access to obj list
	'''
	if(not objExists(parent)):
		printError('connectChainToMeta: ' + parent + "doesn't exist")
	
	parent = PyNode(parent)	
	if not parent.hasAttr(attrName):
		parent.addAttr(attrName, dt = 'string', multi = 1)	
	
	inc = 0
	for obj in objList:
		if(not objExists(obj)):
			printError('connectChainToMeta: ' + obj + "doesn't exists")
		obj = PyNode(obj)
		addMetaParentAttr(obj)
		
		obj.metaParent >> parent.attr(attrName).elementByLogicalIndex(inc) 
		
		inc += 1

def addMetaParentAttr(obj):
	'''	
	add .metaParent attribute to object
	
	obj:
		object to add .metaParent to.
	'''
	if objExists(obj):
		obj = PyNode(obj)
		if not obj.hasAttr('metaParent'):
			obj.addAttr('metaParent', at = 'message')
	else:
		printError("addMetaParentAttr: node given: " + obj + " doesn't exist")
		
def isMetaNode(obj):
	'''
	checks if obj is a meta node
		
	obj:
		object to check
	
	return:
		True if obj is a metaNode
		False if obj is not a metaNode
	'''	
	if not objExists(obj):
		return False
	obj = PyNode(obj)
	if obj.type() == 'network' and obj.hasAttr('metaType'):
		return True
	return False
		
def getMetaNodesOfType(metatype):
	'''
	returns all metaNodes of specified type
	
	metaType:
		the metaType which is wanted
		
	return:
		a list of all the metaNodes of type given in the scene
	'''
	metaList = ls(type = 'network')
	retList = []
	for meta in metaList:
		if isMetaNode(meta) and meta.metaType.get().lower() == metatype.lower():
			retList.append(meta)
	return retList

def isMetaNodeOfType(node, metaType):
	'''
	
	node: node tested
	metaType: checks if meta Node is of same type
	return: true if node is metaNode and of type given
			false if node is not metaNode or of type given
	'''
	if isMetaNode(node) and node.metaType.get() == metaType:
		return True
	return False
	
def getMetaRoot(obj, stopAt= 'CharacterRig'):
	'''
	returns the metaRoot of this object
	'''
	try:
		if not (type(stopAt) is list or type(stopAt) is tuple):
			stopAt = [stopAt]
		if obj.metaType.get() in stopAt:
			return fromNetworkToObject(obj)
	except:
		pass
	try:
		for mp in obj.metaParent.listConnections():
			root = getMetaRoot(mp, stopAt)
			if root:
				return root
	except:	
		pass	

def createSingleIKChain(startJoint, endJoint, compName):
	'''
	create a ik chain
	
	startJoint:
		the starting joint for the chain
	endJoint:
		the ending joint for the chain
	compName:
		will give names to the nodes created, example 'center_spine'
	return:
		[anims, 		0, a list of the anims created
		animZeroGrp, 	1, a list of the groups that makes all transfroms on the anim zero
		anims_grp,		2, the group that hold all the anims
		ik_joints,   	3, a list of all the joints used 
		ik_joints_grp] 	4, a group that holds all the joints
	'''
	
	# get the joints chain
	chain = chainBetween(startJoint, endJoint)
	origChain = duplicateChain(startJoint, endJoint)
	ik_joints = map(lambda x: PyNode(x), chain)
	ik_joint_grp = group(ik_joints[0], n = '%s_ik_joints'%compName)
	
	#create the ik chain
	anims = []
	zeroGrps = []
	for inc in xrange(len(ik_joints)-1):
		base = ik_joints[inc]
		top = ik_joints[inc+1]
		#create Anim
		select(clear=1)
		anim = joint(n = '%s_%i_anim'%(compName, inc+1))
		alignPointOrient(top, anim, 1,1)
		zeroGrp = createZeroedOutGrp(anim)
		addAnimAttr(anim)
		cube = polyCube()[0]
		appendShape(cube, anim)
		delete(cube)
		parentConstraint(anim, top, w=1)
		lockAndHideAttrs(anim, ['sx','sy','sz','v','radius'])
		zeroGrps.append(zeroGrp)
		anims.append(anim)
		
	#rename if there is only one anim
	if len(ik_joints) == 2:
		anims[0].rename("%s_anim"%(compName))
	
	#group all the anims into one group
	animGrp = group(zeroGrps, n = '%s_anims'%compName)
	
	#delete extra nodes
	delete(origChain)
	
	#return
	return [anims, zeroGrps, animGrp, ik_joints, ik_joint_grp]
		
def createNurbsPlaneIKChain(startJoint, endJoint, compName):
	'''
	create stretchy ik controls for the chain
	startJoint:
		the starting joint for the chain
	endJoint:
		the ending joint for the chain
	return:
		[startAnim,   	#0, the ik anim that controls the start of the chain   
		midAnim,		#1  the ik anim that controls the middle of the chain, note: parented contrained between start and end
		endAnim,		#2  the ik anim that controls the end of the chain
		animGrp,		#3  the grp created around the anims and their groups, note: reparent this group instead of the individual anims
		ik_joint_grp, 	#4  the group that contains the joints given, note: joints now aren't in a heirarchy
		nurbsPlane, 	#5  the plane created to control the joints
		transGrp, 		#6  the groups controled by the point on surface nodes
		dummyGrp, 		#7  groups which match joints and are nurbConstrained to surface
		ikLocGrp,		#8  locators to help measure distanced of the joints
		distDimGrp]		#9	distance dimension objects for scaling purposes
	''' 
	#get IK joints 
	chain = chainBetween(startJoint, endJoint)
	origChain = duplicateChain(startJoint, endJoint)
	ik_joints = map(lambda x: PyNode(x), chain)
	ik_joint_grp = group(ik_joints[0], n = '%s_ik_joints'%compName)
	
	#create nurbs plane
	leftCurve = createCurveThroughObjects(origChain)
	rightCurve = createCurveThroughObjects(origChain)
	#PROBLEM: assume the characters rightside and leftside are on the relative Y axis
	movingRight = spaceLocator()
	movingLeft = spaceLocator()
	alignPointOrient(origChain[0], movingRight, 1,1)
	alignPointOrient(origChain[0], movingLeft, 1,1)
	parent(rightCurve, movingRight)
	parent(leftCurve, movingLeft)
	move(movingRight,[0,1,0], r=1, os=1,wd=1)
	move(movingLeft, [0,-1,0], r=1, os=1,wd=1)
	parent(rightCurve, w=1)
	parent(leftCurve, w=1)
	delete(movingRight)
	delete(movingLeft)
	nurbsPlane = loft(leftCurve, rightCurve,ch=0, ss=1, d=3, ar=1, c=0, rn=0, po=0, rsn = 0)[0]
	delete(rightCurve)
	delete(leftCurve)
	
	#connect the joints to the nurbs
		#get lengths
	jointLengths = [0]
	totalLength = 0
	for ik in origChain[1:]:
		length = ik.translateX.get()
		totalLength += length
	
	
	#create Control Joints
	zeroGrps = []
	select(cl=1)
	control_start = joint(n = "%s_ik_start_anim"%compName)
	alignPointOrient(origChain[0], control_start,1,1)
	torus = polyTorus()[0]
	appendShape(torus, control_start)
	delete(torus)
	zeroGrps.append(createZeroedOutGrp(control_start))
	lockAndHideAttrs(control_start, [ 'sx', 'sy', 'sz', 'v', 'radius'])
	addAnimAttr(control_start)
	
	select(cl=1)
	control_mid = joint(n = "%s_ik_mid_anim"%compName)
	alignPointOrient(origChain[len(origChain)/2], control_mid, 1,1)
	torus = polyTorus()[0]
	appendShape(torus, control_mid)
	delete(torus)
	zeroGrps.append(createZeroedOutGrp(control_mid))
	lockAndHideAttrs(control_mid, [ 'sx', 'sy', 'sz', 'v', 'radius'])
	addAnimAttr(control_mid)
	
	select(cl=1)
	control_end = joint(n = "%s_ik_end_anim"%compName)
	alignPointOrient(origChain[-1], control_end, 1,1)
	torus = polyTorus()[0]
	appendShape(torus, control_end)
	delete(torus)
	zeroGrps.append(createZeroedOutGrp(control_end))
	lockAndHideAttrs(control_end, [ 'sx', 'sy', 'sz', 'v', 'radius'])
	addAnimAttr(control_end)
	
	transGroups = []
	dummyGroups = []
	surfacePoints = []
	for ij in ik_joints[:1]:
		dummy = group(empty = 1, n = '%s_dummy_group'%ij.name())
		alignPointOrient(ij, dummy, 1, 1)
		rets = nurbsConstraint(nurbsPlane, dummy, u = .5, v=0)
		parentConstraint(dummy, ij, w=1, mo=1)
		transGroups.append(rets[1])
		dummyGroups.append(dummy)
		surfacePoints.append(rets[2])
		#for the rest of the joints
	length = 0
	for ij in ik_joints[1:-1]:#ik_joints[1:]: 
		dummy = group(empty = 1, n = '%s_dummy_group'%ij.name())
		alignPointOrient(ij, dummy, 1, 1)
		length += ij.translateX.get()
		ratio = length/totalLength
		rets = nurbsConstraint(nurbsPlane, dummy, u= .5, v = ratio)
		parentConstraint(dummy, ij, w=1, mo=1)
		dummyGroups.append(dummy)
		transGroups.append(rets[1])
		surfacePoints.append(rets[2])
	for ij in ik_joints[-1:]:
		dummy = group(empty = 1, n = '%s_dummy_group'%ij.name())
		alignPointOrient(ij, dummy, 1, 1)
		length += ij.translateX.get()
		ratio = length/totalLength
		rets = nurbsConstraint(nurbsPlane, dummy, u= .5, v = ratio)
		parentConstraint(dummy, ij, w=1, mo=1, sr = ['x', 'y', 'z'])
		orientConstraint(control_end, ij, w=1, mo=1)
		dummyGroups.append(dummy)
		transGroups.append(rets[1])
		surfacePoints.append(rets[2])
	
	#constraint the middle anim
	midConstGrp = group(control_mid, n = '%s_start_end_constraint'%control_mid.name())
	#parentConstraint(control_start, control_end, midConstGrp, mo=1, w=1)
	pointConstraint(control_start, control_end, midConstGrp, mo=1, w=1)
	
	#make the scalXe the joints controlled by stretch
	#reparent ikjoints
	for ij in ik_joints[1:]:
		ik_joint_grp | ij
		
	ikScaleLocs = []
	distDims = []
		#create locators
	for inc in xrange(len(ik_joints)):
		ij = ik_joints[inc]
		loc = PyNode(spaceLocator())
		loc.translate.set(ij.getTranslation(space = 'world'))
		select(loc)
		rt.CenterPivot()
		parentConstraint(dummyGroups[inc], loc, w=1, mo=1)
		ikScaleLocs.append(loc)
		#use locators for distance calcs
	for inc in xrange(len(ik_joints)-1):
		ij = ik_joints[inc+1]
		startLoc = ikScaleLocs[inc]
		endLoc = ikScaleLocs[inc+1]
		dist = PyNode(distanceDimension(sp = startLoc.getTranslation(space = 'world'), ep = endLoc.getTranslation(space = 'world')))
		distDims.append(dist)
		ratioMult = createNode('multiplyDivide')# ratio = currentLen/orig
		ratioMult.operation.set(2)
		ratioMult.input2X.set(origChain[inc+1].translateX.get())
		dist.distance >> ratioMult.input1X
		ratioMult.outputX >> ij.scaleX
	
	#make control Joints control nurbsplane
	select(control_start, control_mid, control_end, nurbsPlane)
	rt.SmoothBindSkin()
	
	#grouping
	animGrp = group(zeroGrps, n = '%s_anim_grp'%compName)
	transGrp = group(transGroups, n = '%s_transforms'%compName)
	dummyGrp = group(dummyGroups, n = '%s_dummys'%compName)
	ikLocGrp = group(ikScaleLocs, n = '%s_distance_locators'%compName)
	distDimGrp = group(distDims, n = '%s_distances'%compName)
	
	#turn off inherits transforms
	transGrp.inheritsTransform.set(0)
	dummyGrp.inheritsTransform.set(0)
	nurbsPlane.inheritsTransform.set(0)
	
	#delete
	delete(origChain)
	
	#return
	return(control_start, control_mid, control_end, animGrp, ik_joint_grp, nurbsPlane, transGrp, dummyGrp, ikLocGrp, distDimGrp)
	
def createReverseChain(startJoint, endJoint, compName):
	'''
	return [rev_piv_joint,  #anim
			anim_grp,       #anim_grp
			joint_grp] 		#joint_grp
	'''

	chain = chainBetween(startJoint, endJoint)
	chain = map(lambda x: PyNode(x), chain)
	if not len(chain) == 2:
		raise Exception('ReverseChain.__init__: should only have 2 joints ')
	
	#create control chain
	control_joints = duplicateChain(chain[0], chain[-1], '_joint', '_control_joint')
	
	
	#create reverse Joints
	select(cl=1)
	piv_pos = chain[-1].getTranslation(space = 'world')
	rot_pos = chain[0].getTranslation(space = 'world')
	rev_piv_joint = joint(p = piv_pos)
	rev_rot_joint = joint(p = rot_pos, n = "%s_rot_joint"%compName)
	joint(rev_piv_joint, e=1, zso=1, oj='xyz', sao='yup')
	
	#make pivot joint into anim
	addBoxToJoint(rev_piv_joint)
	lockAndHideAttrs(rev_piv_joint, ['tx', 'ty', 'tz', 'sx', 'sy', 'sz', 'v', 'radius'])
	addAnimAttr(rev_piv_joint)
	rev_piv_joint.rename('%s_anim'%compName)		
	
	#parent Constrain to control and bind joints
	parentConstraint(rev_rot_joint, control_joints[0],mo=1,w=1)
	
	for inc in xrange(len(chain)-1):
		parentConstraint(control_joints[inc], chain[inc])
				
	#group
	jointGrp = group(control_joints[0], n = "%s_joint_group")
	animGrp = group(rev_piv_joint, n = "%s_anim_group")
				
	return [rev_piv_joint, animGrp, jointGrp]
	
	
#meta classes			
class MetaNode():
		def __init__(self, metaType, metaVersion, metaDescription):
			'''
			metaType:
				the type of rig Component
			metaVersion:
				what version is the component in
			metaDescription:
				a brief description of what the metaComponent does			
			'''
			self.networkNode = createNode('network', n = metaType)
			self.networkNode.setAttr('metaType', metaType ,f=1)
			self.networkNode.setAttr('metaVersion', metaVersion ,f=1)
			self.networkNode.setAttr('metaDescription', metaDescription ,f=1)
		
		def metaType(self):
			'''
			returns the metaType of the metaNode
			'''
			return self.networkNode.getAttr('metaType')
		
			
		def metaVersion(self):
			'''	
			returns the version of the metaNode
			'''
			return self.networkNode.getAttr('metaVersison')
		
			
		def metaDescription(self):
			'''
			returns the meta description of the metaNode
			'''
			return self.networkNode.getAttr('metaVersison')
		
		
		def __str__(self):
			'''
			the to string method
			'''
			return '[%s::%s]'%(self.networkNode.metaType.get(),self.networkNode.name())
			
		def __eq__(self, other):
			try:
				return self.networkNode == other.networkNode
			except:
				return False

class Manager(MetaNode):
	def __init__(self, node = None):
		"""
		node:
			existing network node of a Manager Meta Node
		"""		
		if node:
			pass
		else:
			MetaNode.__init__(self, 'SceneManager', 1.0, 'Contains info about the Scene')
			self.networkNode.addAttr('file_path', dt = 'string')
			mc.file(q=1, l=1)[0]
			self.file_name = self.file_path.split('/')[-1][:-3]
			self.rigs 
			self.lights = []
			self.efx = []

		
	def saveIter(self):
		'''		
		saves an iteration of the scene in the iterations folder, if iterations folder doesnt exist it will create one
		'''
		SaveIterWindow()

		
	def addLightGroup(self, lightGrp):
		'''
		adds a light group to the manager node
		'''
		pass

class LightGroup(MetaNode):
		def __init__(self, groupName ,node = ''):
			'''
			groupName:
				the name of the lightGroup
			node:
				an existing LightGroup meta Node
			'''
			if node:
				if objExists(node):
					node = PyNode(node)
					if( isMetaNode(node) and node.metaType.get() == 'LightGroup'):
						self.networkNode = node
					else:
						printError("LightGroup: node %s is not a LightGroup metaNode"%(node))
				else:
					printError("LightGroup: node %s doesn't exist"%(node))
					
			else:
				MetaNode.__init__(self, 'LightGroup', 1.0, 'Contains info about lights in Group')
				self.networkNode.setAttr('groupName', groupName ,f=1)
				self.networkNode.addAttr('keys', dt = 'string', m=1)
				self.networkNode.addAttr('fills', dt = 'string', m=1)
				self.networkNode.addAttr('rims', dt = 'string', m=1)
				self.networkNode.addAttr('others', dt = 'string', m=1)
				
		
		def createLightByType(self, lightType):
			'''
			creates a light
			'''
			if lightType.lower() == 'spot':
			    return spotLight().getParent()
			elif lightType.lower() == 'directional':
			    return directionalLight().getParent()
			elif lightType.lower() == 'point':
			    return pointLight().getParent()
			elif lightType.lower() == 'volume':
			    return createNode('volumeLight').getParent()
			elif lightType.lower() == 'area':
			    return createNode('areaLight').getParent()
			elif lightType.lower() == 'ambient':
			    return ambientLight().getParent()
			else:
			    print 'WARNING LIGHT NOT CREATED'
			    return None

		def addLightToRims(self, light):
			'''
			adds the given light to the rim lights
			light:
				light to add to rims
			'''
			self.addLightToGroup(light, 'rims')
		
		def addLightToKeys(self,light):
			'''
			adds the given light to the key lights
			light:
				light to add to keys
			'''
			self.addLightToGroup(light, 'keys')
			
		def addLightToOthers(self, light):
			'''
			adds the given light to the other lights
			light:
				light to add to other
			'''
			self.addLightToGroup(light, 'others')

		def addLightToFills(self,light):
			'''
			adds the given light to the fill lights
			light:
				light to add to fills
			'''
			self.addLightToGroup(light, 'fills')

		def addLightTypeToRims(self, ltype):
			'''
			creates light of ltype and adds it to rims
			ltype:
				the light type, (point, area, spot, ...)
			'''
			self.addLightToGroup(self.createLightByType(ltype), 'rims')
	
		def addLightTypeToKeys(self, ltype):
			'''
			creates light of ltype and adds it to keys
			ltype:
				the light type, (point, area, spot, ...)
			'''
			self.addLightToGroup(self.createLightByType(ltype), 'keys')
		
		def addLightTypeToOthers(self, ltype):
			'''
			creates light of ltype and adds it to others
			ltype:
				the light type, (point, area, spot, ...)
			'''
			self.addLightToGroup(self.createLightByType(ltype), 'others')
	
		def addLightTypeToFills(self, ltype):
			'''
			creates light of ltype and adds it to fills
			ltype:
				the light type, (point, area, spot, ...)
			'''
			self.addLightToGroup(self.createLightByType(ltype), 'fills')	

		def addSelectedLightsToGroup(self, groupName):
			'''
			adds all the selected lights to the group given
			groupName:
				the group to add the lights to, (keys, rims, fills, others)
			'''
			selection = ls(sl=1)
			allLights = ls(type = 'lights')
			for item in selection:
				shape = item.getShape()
				if shape in allLights:
					self.addLightToGroup(item, groupName)	
			
		def addLightToGroup(self, light, groupName):
			'''
			adds the given light to the given group
			light:
				the light to add to the group
			groupName:
				the name of the group to add the light to, (keys, fills, rims, others)
			return:
				true if added, else false
			'''
			#see if the group name exists if it doesn't return None
			try:
				self.networkNode.attr(groupName)
			except MayaAttributeError:
				print "LightGroup.addLightToGroup: got MayaAttributeError, group doesn't exist"
	
			#if light already is in group or doesn't exist, don't add light
			
			if (not objExists(light)) or (light in self.networkNode.attr(groupName).get()):
				return None
			number = 0
			groups = ['rims','fills','keys','others']
			groupName = groupName.lower()
			if groupName in groups:
					number = self.networkNode.attr(groupName).numElements()
					connectToMeta(light, self.networkNode, '%s[%i]'%(groupName, number) )
			return True

		def RemoveLightFromGroup(self, light, groupName):
			'''
			removes the light grom the group specified
			light:
				the light to remove
			groupName:
				the name of the group to remove from
			return:
				return the light if removed, else false
			'''
			#see if the group name exists if it doesn't return None
			try:
				self.networkNode.attr(groupName)
			except MayaAttributeError:
				print "LightGroup.addLightToGroup: got MayaAttributeError, group doesn't exist"
			#if light already is in group or doesn't exist, don't add light
			
			if (not objExists(light)) or (light in self.networkNode.attr(groupName).get()):
				return None
			
			groups = ['rims','fills', 'keys', 'others']	
			groupName = groupName.lower()
			if groupName in groups:
				for num in xrange(self.networkNode.attr(groupName).numElements()):
					if listConnections(self.networkNode.attr('%s[%i]'%(groupName,num)))[0] == light:
						self.networkNode.attr('%s[%i]'%(groupName, num)).remove(b=1)
						return light
			
							
		def getAllLights(self):
			'''
			return all the lights in the light group
			'''
			allLights = []
			map((lambda x:allLights.append(x)),self.getRims())
			map((lambda x:allLights.append(x)),self.getKeys())
			map((lambda x:allLights.append(x)),self.getFills())
			map((lambda x:allLights.append(x)),self.getOthers())
			return allLights
	
		def getKeys(self):
			'''
			return all the key lights
			'''
			return self.networkNode.keys.get()
			
		def getFills(self):
			'''
			return all the fill lights
			'''
			return self.networkNode.fills.get()
			
		def getRims(self):
			'''
			return all the rim lights
			'''
			return self.networkNode.rims.get()
			
		def getOthers(self):
			'''
			return all the other lights
			'''
			return self.networkNode.others.get()

		def selectRimLights(self):
			'''
			replace selection with rim lights
			'''
			select(cl=1)
			map((lambda x: select(x, add=1)), self.getRims())
		
		def selectKeyLights(self):
			'''
			replace selection with the key lights
			'''
			select(cl=1)
			map((lambda x: select(x, add=1)), self.getKeys())
		
		
		def selectFillLights(self):
			'''
			replace selection with the fill lights
			'''
			select(cl=1)
			map((lambda x: select(x, add=1)), self.getFills())
		
		def selectOtherLights(self):
			'''
			replace selection with the other lights
			'''
			select(cl=1)
			map((lambda x: select(x, add=1)), self.getOthers())
		
		def selectAllLights(self):
			'''
			replace selection with all the lights in the LightGroup
			'''
			select(cl=1)
			map((lambda x: select(x, add=1)), self.getAllLights())
			
		def getNetworkNode(self):
			'''
			retrun the networkNode of this metaNode
			'''
			return self.networkNode
			
		def getGroupName(self):
			'''
			return the name of this LightGroup
			'''
			return self.networkNode.groupName.get()

		def appendLightGroup(self, other):
			'''
			append all the lights from other group into this group
			
			other:
				the other LightGroup
			'''
			
			for light in other.getKeys():
				self.addLightToKeys(light)
			for light in other.getFills():
				self.addLightToFills(light)
			for light in other.getRims():
				self.addLightToRims(light)
			for light in other.getOthers():
				self.addLightToOthers(light)
				
class GeometryGroup(MetaNode):
	def __init__(self, groupName ,node = ''):
		'''
		groupName:	
			name of the Geometry Group
		node:
			an existing geometry Node
		'''	
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'GeometryGroup'):
					self.networkNode = node
				else:
					printError("GeometryGroup: node %s is not a GeometryGroup metaNode"%(node))
			else:
				printError("GeometryGroup: node %s doesn't exist"%(node))
		else:
			MetaNode.__init__(self, 'GeometryGroup', 1.0, 'groups Geometry into sections')
			self.networkNode.setAttr('groupName', groupName ,f=1)
			self.networkNode.addAttr('resGroups', dt = 'string', multi = 1)

						
	def hideAllGeo(self):
		'''
		hide all geometry in the group
		'''
		ress = self.getResGroups()
		for res in ress:
			res.setVisibility(0)
			
	def showAllGeo(self):
		'''
		unhides all geometry in the group
		'''
		ress = self.getResGroups()
		for res in ress:
			res.setVisibility(1)
			
	def makeHighGeo(self):
		'''
		makes all the geometry in the group highPoly
		'''
		ress = self.getResGroups()
		for res in ress:
			res.setToHigh()
			
	def makeLowGeo(self):
		'''
		makes all the geometry in the group low poly 
		'''
		ress = self.getResGroups()
		for res in ress:
			res.setToLow()
		
	def getGroupName(self):
		'''
		returns the name of the GeometryGroup
		'''
		return self.networkNode.groupName.get()
		
	def getResGroups(self, network = None):
		'''
		returns all the GeoResGroups in the GeometryGroup
		network:
			will return the networkNodes instead of the GeoResGroup object
		'''
		ress = listConnections(self.networkNode.resGroups)
		if network:
			return ress
		
		newlist = []
		
		for obj in ress:
			if obj:
				buff = GeometryResGroup("", node = obj)
				newlist.append(buff)
		return newlist
		
	def addResGroup(self, res):
		'''
		adds the res group to this Geometry Group
		res:
			the GeometryResGroup to add		
		'''
		if( objExists(res) and isMetaNode(res) and res.metaType.get() == 'GeometryResGroup'):
			numElements = self.networkNode.resGroups.numElements()
			attr = 'resGroups[%i]'%numElements
			connectToMeta(res, self.networkNode,attr )
		else:
			printError("addResGroup: node %s is not a GeometryResGroup"%res)
		
class GeometryResGroup(MetaNode):
	def __init__(self, groupName, low = None , high= None, node = ''):
		'''
		groupName:
			name of this resGroup
		low:
			low poly geometry
		high:
			high poly geometry
		node:
			an existing GeometeryResGroup meta node
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'GeometryResGroup'):
					self.networkNode = node
					if low:
						self.setLowPolyGeo(low)
					if high:
						self.setHighPolyGeo(high)	 
				else:
					printError("GeometryGroup: node %s is not a GeometryGroup metaNode"%(node))
			else:
				printError("GeometryGroup: node %s doesn't exist"%(node))
		else:
			MetaNode.__init__(self, 'GeometryResGroup', 1.0, 'contains high-res and low-res geos of objects')
			self.networkNode.setAttr('groupName', groupName, f=1)
			self.networkNode.addAttr('highPolyGeo', dt = 'string')
			self.setHighPolyGeo(high)
			self.networkNode.addAttr('lowPolyGeo', dt = 'string')
			self.setLowPolyGeo(low)
			self.networkNode.setAttr('isHighRes', 0, f = 1 )
			self.networkNode.setAttr('isVisible',1,f=1)
			self.setToLow()
			self.setVisibility(1)
	
	def renameGroup(self, newName):
		'''
		renames the GeometryResGroup to the new name
		newName:
			the name to change to
		'''
		if newName:
			self.networkNode.groupName.set(newName)
					
	def setLowPolyGeo(self, geo):
		'''
		sets the lowPoly geometry for the ResGroup
		'''
		if objExists(geo) and nodeType(geo) == 'transform':
			connectToMeta(geo, self.networkNode, 'lowPolyGeo')
		else:
			printError("GeometryResGroup.SetLowPolyGeo: geo given %s doesn't exist or isn't transform node"%geo)
	
	def getGroupName(self):
		'''
		return the name of the group
		'''
		return self.networkNode.groupName.get()
			
	def setHighPolyGeo(self, geo):
		'''
		sets the the highPoly geometry for the ResGroup
		'''
		if objExists(geo) and nodeType(geo) == 'transform':
			connectToMeta(geo, self.networkNode, 'highPolyGeo')
		else:
			printError("GeometryResGroup.SetHighPolyGeo: geo given %s doesn't exist or isn't transform node"%geo)
			
	def toggleRes(self):
		'''
			if geometry is low poly then turn to high, else turn to low
		'''
		state = self.networkNode.isHighRes.get()
		if state:
			setToLow()
		else:
			setToHigh()

	def setToHigh(self):
		'''
		sets the group to high Poly
		'''
		if listConnections(self.networkNode.lowPolyGeo) and listConnections(self.networkNode.highPolyGeo):
			self.networkNode.isHighRes.set(1)
			if self.networkNode.isVisible.get():
				listConnections(self.networkNode.lowPolyGeo)[0].visibility.set(0)
				listConnections(self.networkNode.highPolyGeo)[0].visibility.set(1)
		else:
			print("setToHigh: doesn't have both high and low geometry")
		
	def setToLow(self):
		'''
		sets the group to lowPoly
		'''
		if listConnections(self.networkNode.lowPolyGeo) and listConnections(self.networkNode.highPolyGeo):
			self.networkNode.isHighRes.set(0)
			if self.networkNode.isVisible.get():
				listConnections(self.networkNode.lowPolyGeo)[0].visibility.set(1)
				listConnections(self.networkNode.highPolyGeo)[0].visibility.set(0)
		else:
			print("setToHigh: doesn't have both high and low geometry")
	
	def isHighRes(self):
		'''
		return True if ResGroup is high Poly
		'''
		return self.networkNode.isHighRes.get()
	
	def setVisibility(self, var):
		'''
		set the visibility of the ResGroup, if 1, then geometry is visible, else: all geometry is hidden
		'''
		self.networkNode.isVisible.set(var)
		listConnections(self.networkNode.lowPolyGeo)[0].visibility.set(bool(var and (1-self.networkNode.isHighRes.get())))
		listConnections(self.networkNode.highPolyGeo)[0].visibility.set(bool(var and self.networkNode.isHighRes.get()))
			
	def isVisible(self):
		'''
		return is the geometry is visible
		'''
		return self.networkNode.isVisible.get()
		
	def toggleVis(self):
		'''
		if geometry is visible then hides them, else: shows geometry
		'''
		self.setVisibility(1 - self.isVisible())

class CharacterRig(MetaNode):
	def __init__(self, characterName, upDirection, forwardDirection, node = ''):
		'''
		characterName:
			the name of the character
		upDirection:
			the axis of the charcters up direction
		forwardDirection:
			the axis of the characters forward direction
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'CharacterRig'):
					self.networkNode = node
				else:
					printError("CharacterRig: node %s is not a CharacterRig metaNode"%(node))
			else:
				printError("CharacterRig: node %s doesn't exist"%(node))
		else:
			MetaNode.__init__(self, 'CharacterRig', 1.0, 'contains the charcter rig information')
			#error test inputs
			directions = ['x', 'y', 'z', '-x', '-y', '-z']
			if not upDirection in directions:
				raise Exception("CharacterRig.__init__(): upDirection should be one of %s"%directions.__repr__())
			if not forwardDirection in directions:
				raise Exception("CharacterRig.__init__(): forwardDirection should be one of %s"%directions.__repr__())
			if directions.index(upDirection) % 3 == directions.index(forwardDirection)%3:
				raise Exception("CharacterRig__init__(): forwardDirection and upDirection should are on same axis")
			
			rootJoint = getJointsByLabel('center', 'root')
			
			topCon = joint(p = [0,0,0], n = "%s_topCon"%characterName)
			lockAndHideAttrs(topCon, ['radius'])
			topCon.scaleX.set(keyable = 0, cb = 0)
			topCon.scaleY.set(keyable = 0, cb = 0)
			topCon.scaleZ.set(keyable = 0, cb = 0)
			topCon.addAttr('globalScale', dv = 1, min = .000001, keyable = 1)
			topCon.globalScale >> topCon.scaleX
			topCon.globalScale >> topCon.scaleY
			topCon.globalScale >> topCon.scaleZ
			addAnimAttr(topCon)
			
			compGrp = group(empty = 1, n = 'component grp')
			bindGrp = group(rootJoint, n = "bind joint grp")
			meshGrp = group(empty = 1, n = "mesh grp")
			meshGrp.inheritsTransform.set(0)
			parent([compGrp, bindGrp, meshGrp], topCon)
			
			#connectToMeta
			self.networkNode.setAttr('characterName', characterName, f=1)
			self.networkNode.addAttr('rigComponents',dt = 'string', m=1)
			self.networkNode.addAttr('meshes',dt = 'string', m=1)
			self.networkNode.setAttr('upDirection', upDirection, f=1)
			self.networkNode.addAttr('leftShader', dt = 'string')
			self.networkNode.addAttr('rightShader', dt = 'string')
			self.networkNode.addAttr('centerShader', dt = 'string')
			self.networkNode.setAttr('forwardDirection', forwardDirection, f=1)
			connectToMeta(meshGrp, self.networkNode, 'meshGrp')
			connectToMeta(bindGrp, self.networkNode, 'bindGrp')
			connectToMeta(topCon, self.networkNode, 'topCon')
			connectToMeta(compGrp, self.networkNode, 'compGrp')
	
	def addSmoothToTopCon(self):
		topCon = self.getTopCon()
		topCon.addAttr("smooth", dv = 0, min = 0, max = 1, keyable = 0)
		setAttr(topCon + ".smooth", cb=True)
		meshes = self.getAllMeshes()
		for mesh in meshes:
			connections = mesh.getShape().listConnections(type="polySmoothFace")
			if (len(connections) > 0):
				connectAttr(topCon + ".smooth", connections[0] + ".divisions")

	def getAllMeshes(self):
		'''
		returns a list of all connected meshes
		'''
		allMeshes = self.networkNode.meshes.listConnections()
		return allMeshes
		
		
	def getLeftSideDirection(self):
		'''
		get the direction of the characters side
		return: 
			(-)(x,y,z)
		'''
		allOptions = {
		('x', 'y'): "-z",
		('x', '-y'): "z",
		('x', 'z'): "y",
		('x', '-z'): "z",
		('-x', 'y'): 'z',
		('-x', '-y'): '-z',
		('-x', 'z'): '-y',
		('-x', '-z'): 'y',
		('y', 'x'): "z",
		('y', '-x'): "-z",
		('y', 'z'): "-x",
		('y', '-z'): "x",
		('-y', 'x'): '-z',
		('-y', '-x'): 'z',
		('-y', 'z'): 'x',
		('-y', '-z'): '-x',
		('z', 'x'): "-y",
		('z', '-x'): "y",
		('z', 'y'): "x",
		('z', '-y'): "-x",
		('-z', 'x'): 'y',
		('-z', '-x'): '-y',
		('-z', 'y'): '-x',
		('-z', '-y'): 'x'
		}	
		
		return allOptions[(self.getForwardDirection(), self.getUpDirection())]
	
	def addMesh(self, mesh):
		'''
		add a mesh to the character rig, a mesh is a mesh to bind to joints
		mesh:
			mesh to bind at later time
		'''
		if not objExists(mesh):
			raise Exception("CharacterRig.addMesh: mesh obj , %s ,doesn't exist"%mesh)
		parent(mesh, self.networkNode.meshGrp.listConnections()[0])
		connectToMeta(mesh, self.networkNode, 'meshes')
					
	def addRigComponent(self, rigComponent):
		'''
		connects the rigComponent to the character and parent it under the component group
		rigComponent:
			the rigComponent to connect
		'''
		connectToMeta(rigComponent.networkNode,self.networkNode, 'rigComponents')
		rigComponent.parentUnder(self.networkNode.compGrp.listConnections()[0])
		
	def getCharacterName(self):
		'''
		returns the name of the character
		'''
		return self.networkNode.characterName.get()
	
	def getUpDirection(self):
		'''
		return the axis of the characters up direction
		return:
			string (-)(x,y,z)
		'''
		return self.networkNode.upDirection.get()
		
	def getForwardDirection(self):
		'''
		return the axis of the characters forward direction
		return:
			string (-)(x,y,z)
		'''
		return self.networkNode.forwardDirection.get()
	
	def getOppositeComponent(self, comp):
		'''
		get the opposite component of component given
		'''
		if not comp.getCharacterRig() == self:
			raise Exception("CharacterRig.getOppositeComponent: component, %s, doesn't belong to this character rig")
		side = comp.networkNode.side.get().lower()
		bodyPart = comp.networkNode.bodyPart.get().lower()
		if side == 'center':
			return comp
		else:
			allComps = self.networkNode.rigComponents.listConnections()
			for c in allComps:
				otherSide = c.side.get().lower()
				otherBodyPart = c.bodyPart.get().lower()
				if otherBodyPart == bodyPart:
					if otherSide == 'left' and side == 'right':
						return fromNetworkToObject(c)
					elif otherSide == 'right' and side == 'left':
						return fromNetworkToObject(c)
		return comp
		
	def getAllRigComponents(self):
		'''
		returns a list of all the rigComponents
		'''
		allComps = self.networkNode.rigComponents.listConnections()
		allComps = map(lambda x: fromNetworkToObject(x), allComps)
		return allComps
				
	def getTopCon(self):
		'''
		returns the topCon anim
		'''
		return self.networkNode.topCon.listConnections()[0]
		
	def getAllAnims(self, side = ""):
		'''
		returns a list of all the anims associate with this rig
		'''
		components = self.networkNode.rigComponents.listConnections()
		components = map(lambda x: fromNetworkToObject(x), components)
		allAnims = []
		if side:
			for comp in components:
				if comp.getSide().lower() == side:
					anims = comp.getAllAnims()
					map(lambda x: allAnims.append(x), anims)
			#if side == "center":
			#	allAnims.append(self.getTopCon())
			return allAnims
		else:
			for comp in components:
				compAnims = comp.getAllAnims()
				for anim in compAnims:
					allAnims.append(anim)
			allAnims.append(self.getTopCon())
			return allAnims
		
	def keyAllAnims(self):
		'''
		keys all the anims in the rig
		'''
		anims = self.getAllAnims()
		for anim in anims:
			setKeyframe(anim)
			
	def selectAllAnims(self):
		'''
		selects all the anims of the rig
		'''
		select(clear = 1)
		anims = self.getAllAnims()
		for anim in anims:
			select(anim, add=1)
	
	def toDefaultPose(self):
		'''
		moves the character to the placement of initial rig
		'''
		allComps = self.getAllRigComponents()
		for comp in allComps:
			comp.toDefaultPose()
			
	def mirrorPose(self):
		'''
		mirrors the whole character
		'''
		components = self.getAllRigComponents()
		notComps = []
		for comp in components:
			if not comp in notComps:
				comps = comp.mirror(bothSides=1)
				for x in comps:
					notComps.append(x)
					
	def createLayer(self, layerName, objs, template = 0, visible = 1, reference = 0):
		'''
		creates a display layer for the rig, and connects it to the rig for tracking
		'''
		select(objs)
		layer = createDisplayLayer(name = self.networkNode.characterName.get() + "_" + layerName, nr=1)
		layer.visibility.set(visible)
		if reference:
			layer.displayType.set(2) 
		else:
			if template:
				layer.displayType.set(1)
		connectChainToMeta([layer], self.networkNode, 'layers')
		
	def exportAnims(self, folder):
		'''
		exports all the anims to a folder for faster creation later
		'''
		for x in self.getAllAnims():
			if hasAnimAttr(x):
				print "exporting:", x
				name = x.name()
				grp = group(empty=1, name = name)
				alignPointOrient(x, grp,1,1)
				appendShape(x, grp)
				select(grp)
				hyperShade(assign = "lambert1")
				select(grp)
				exportPath = folder + "/" + name + ".ma"
				rt.ConvertInstanceToObject(grp)
				exportSelected(exportPath,f=1, typ = "mayaAscii")
				delete(grp)
				select(cl=1)
			
	def importAnims(self, folder):
		'''
		imports all anims from a folder
		'''
		for x in self.getAllAnims():
			name = x.name()
			print x
			if not os.path.isdir(folder):
				printError("rig.importAnims: %s is not a directory"%s)
			fileName = folder + "/" + name + ".ma"
			if not os.path.exists(fileName):
				print("rig.importAnims: no file matched for %s"%name)
			else:
				newNodes = importFile(fileName, f=1, returnNewNodes =1, defaultNamespace =1)
				goodNodes = []
				for y in newNodes:
					if y.type() == 'transform':
						if y.getShape():
							goodNodes.append(y)
							goodNodes.append(y.getShape())
				newNodes.remove(goodNodes[0])
				newNodes.remove(goodNodes[1])
				newObj = goodNodes[0]
				alignPointOrient(x, newObj,1,1)
				addRot = x.rotateAxis.get()
				rotate(newObj, addRot, os =1, r=1)
				makeIdentity(newObj, apply =1, t=1, r=1, s=1)
				swapShape(x, newObj)
				
	def createShader(self, side, color= [1,0,0], opacity = .5, apply = 0):
		'''
		creates shaders and connects to metaNode
		return the material created
		'''
		side = side.lower()
		topCon = self.getTopCon()
		if not topCon.hasAttr("animOpacity"):
			topCon.addAttr("animOpacity")
			topCon.animOpacity.setMax(1)
			topCon.animOpacity.setMin(0)
		topCon.animOpacity.set(opacity)
		topCon.animOpacity.setKeyable(1)
		if side in ('left', 'right', 'center'):
			shader = shadingNode('lambert', asShader=1, n = '%s_%s_anim_mat'%(self.getCharacterName(), side));
			shader.color.set(color)
			topCon.animOpacity >> shader.transparency.transparencyR
			topCon.animOpacity >> shader.transparency.transparencyG
			topCon.animOpacity >> shader.transparency.transparencyB
			connectToMeta(shader, self.networkNode, '%sShader'%side)
			if apply:
				select(self.getAllAnims(side))
				if side == "center":
					shp = self.getTopCon().getShape()
					if shp:
						select(shp, add=1)
				hyperShade(assign = shader)
				select(cl=1)
		else:
			printError("side given isn't valid")
			
class RigComponent(MetaNode):
	def __init__(self, metaType, metaVersion, metaDescription, side, bodyPart, startJoint = "", endJoint = ""):
		'''
		metaType:
			the type of rig Component
		metaVersion:
			what version is the component in
		metaDescription:
			a brief description of what the metaComponent does
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		MetaNode.__init__( self, metaType, metaVersion, metaDescription)
		self.networkNode.setAttr('side', side, f=1)
		self.networkNode.setAttr('bodyPart', bodyPart, f=1)
		if startJoint:
			connectToMeta(startJoint, self.networkNode, 'startJoint')
		if endJoint:
			connectToMeta(endJoint, self.networkNode, 'endJoint')
		if startJoint == endJoint:
			raise Exception('RigComponent: endJoint == startJoint')
		
		
	
	
	
	def getSide(self):
		'''
		returns the side of the rigComponent
		'''
		return self.networkNode.side.get()
		
	def getBodyPart(self):
		'''
		returns the body Part of the rigComponent
		'''
		return self.networkNode.bodyPart.get()
	
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		pass
		
	def getCharacterRig(self):
		'''
		Get the character Rig node that this component belongs to
		'''
		metaType = self.networkNode.metaType.get()
		node = self.networkNode
		while metaType != 'CharacterRig':
			if node == None:
				return None
			try:
				newNode = node.metaParent.listConnections()[0]
				node = newNode
			except:
				node = None
			try:
				metaType = node.metaType.get()
			except:
				metaType = "None"
		return CharacterRig('','','',node = node)
					
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		raise Exception("can't connect this component connectToComponent() not implemented, %s"%self.networkNode.metaType.get())
		
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		raise Exception("can't connect to this component getConnectObj() not implemented, %s"%self.networkNode.metaType.get())
	
	def isIK(self):
		'''
		returns true if component has an IK chain, else false
		'''
		return False
	
	def getIK(self):
		'''
		returns the IK handle
		'''
		return None
		
	def isFK(self):
		'''
		returns true if component has an fk chain
		'''
		return False
	
	def getFK(self):
		'''
		return the jk joints
		'''
		try:
			return self.networkNode.FKJoints.listConnections()	
		except:
			return None
		
	def isSwitch(self):
		'''
		return True if component switches between two types of chains
		'''
		return None
			
	def getBindJoints(self):
		'''
		return the joints which should be bound to
		'''
		try:
			return self.networkNode.bindJoints.listConnections()
		except:
			return None 
	
	def parentUnder(self, obj):
		'''
		parent this rigComponent under the obj
		obj:
			object to parent under
		'''
		if not objExists(obj):
			raise Exception("RigComponent: can't parent under $s, obj doesn't exist"%obj)
		try:
			parent(self.networkNode.componentGrp.listConnections()[0], obj)
		except:
			raise Exception("%s.parentUnder: not implemeneted"%self.networkNode.metaType.get())
	
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		return None
		
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''			
		pass
			
	def __str__(self):
		node = self.networkNode
		return "%s:: %s %s, %s"%(node.metaType.get(), node.side.get(), node.bodyPart.get(), node.name())

class FKChain(RigComponent):
	def __init__(self, side, bodyPart, startJoint, endJoint, node = '', stretchy = 0):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'FKChain'):
					self.networkNode = node
				else:
					printError("FKChain: node %s is not a FKChain metaNode"%(node))
			else:
				printError("FKChain: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'FKChain', 1.0, 'chain of FK Joints', side, bodyPart, startJoint, endJoint)
			chain = chainBetween(startJoint, endJoint)
			bind_joints = []
			compName = '%s_%s'%(side, bodyPart)
			for item in chain:
				item = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
			
			fk_joints = duplicateChain(bind_joints[0],bind_joints[-1], 'bind', 'FK')
			
			for inc in xrange(len(fk_joints)-1):
				obj = fk_joints[inc]
				addBoxToJoint(obj)
				lockAndHideAttrs(obj, ['tx', 'ty', 'tz', 'sx', 'sy', 'sz', 'v', 'radius'])
				addAnimAttr(obj)
				obj.rename('%s_%i_anim'%(compName, inc+1))
			
			globalMultiplier = createNode('multiplyDivide')
			if stretchy:
				#create stretch attr
				fk_joints[-2].addAttr("stretch", dv = 1, min = .000001, keyable =1)
				for x in fk_joints[:-2]:
					x.addAttr("stretch", dv = 1, min = .000001, keyable = 1)
					fk_joints[-2].stretch >> x.stretch
					x.stretch.lock()
				
				#create basic setup with calc nodes
					#multipler
				fk_joints[-2].stretch >> globalMultiplier.input1X
				globalMultiplier.input2X.set(1)

				#add stretchy to the FK joints
				for j in fk_joints[1:]:
					jointMult = createNode('multiplyDivide')
					orig = j.translateX.get()
					jointMult.input1X.set(orig)
					j.translateX.unlock()
					globalMultiplier.outputX >> jointMult.input2X
					jointMult.outputX >> j.translateX
				
				
			#rename if there is only one anim
			if len(fk_joints) == 2:
				fk_joints[0].rename("%s_anim"%(compName))
				
			for inc in xrange(len(bind_joints)-1):
				parentConstraint(fk_joints[inc], bind_joints[inc], w=1)
				
			#grouping
			select(cl=1)
			animGrp = group(fk_joints[0], n = "%s_anim_grp"%compName)
			mainGrp = group([animGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
				
			#connectToMeta
			self.networkNode.setAttr('stretchy', stretchy,  f=1)
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
			connectChainToMeta(fk_joints, self.networkNode, 'FKJoints')
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			
			select(cl=1)
	
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
	
	
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.FKJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.FKJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("FKChain.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			fk_joints = self.networkNode.FKJoints.listConnections()
			for inc in xrange(len(fk_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return fk_joints[inc]
				if location == fk_joints[inc]:
					return fk_joints[inc]
		raise Exception("FKChain.getConnectObj: location wasn't found, try 'start', 'end', or name of bind or fk joint ")

	def isFK(self):
		return True
		
	def getAnims(self):
		'''
		returns all the anims associated with the FK chain
		'''
		return self.networkNode.FKJoints.listConnections()[:-1]
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		if other == self:
			for anim in self.getAnims():
				rot = anim.rotate.get()
				anim.rotate.set(-rot[0],-rot[1],rot[2])
			return [self]
		else:
			allAnims = self.getAnims()
			allRots = []
			map(lambda x: allRots.append(x.rotate.get()), allAnims)
			if bothSides:
				otherAnims = other.getAnims()
				otherRots = []
				map(lambda x: otherRots.append(x.rotate.get()), otherAnims)
				inc = 0
				for anim in allAnims:
					anim.rotate.set(otherRots[inc])
					inc += 1
				inc = 0
				for anim in otherAnims:
					anim.rotate.set(allRots[inc])
					inc+=1
				return [self, other]
			else:
				otherAnims = other.getAnims()
				otherRots = []
				map(lambda x: otherRots.append(x.rotate.get()), otherAnims)
				inc = 0
				for anim in allAnims:
					anim.rotate.set(otherRots[inc])
					inc += 1
				return [self]
				
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		return self.getAnims()
	
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''			
		anims = self.getAllAnims()
		for anim in anims:
			resetAttrs(anim)
			
			
class COGChain(RigComponent):
	def __init__(self, side, bodyPart, startJoint, endJoint, node = '', stretchy = 0):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		note, similar to FKChain but doesn't constrain the start joint, and also allows for translation
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'COGChain'):
					self.networkNode = node
				else:
					printError("COGChain: node %s is not a COGChain metaNode"%(node))
			else:
				printError("COGChain: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'COGChain', 1.0, 'center of gravity component', side, bodyPart, startJoint, endJoint)
			chain = chainBetween(startJoint, endJoint)
			bind_joints = []
			compName = '%s_%s'%(side, bodyPart)
			for item in chain:
				item = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
			
			fk_joints = duplicateChain(bind_joints[0],bind_joints[-1], 'bind', 'FK')
			
			for inc in xrange(len(fk_joints)-1):
				obj = fk_joints[inc]
				addBoxToJoint(obj)
				lockAndHideAttrs(obj, ['sx', 'sy', 'sz', 'v', 'radius'])
				addAnimAttr(obj)
				obj.rename('%s_%i_anim'%(compName, inc+1))
				
			
			
			globalMultiplier = createNode('multiplyDivide')
			if stretchy:
				#create stretch attr
				fk_joints[-2].addAttr("stretch", dv = 1, min = .000001, keyable =1)
				for x in fk_joints[:-2]:
					x.addAttr("stretch", dv = 1, min = .000001, keyable = 1)
					fk_joints[-2].stretch >> x.stretch
					x.stretch.lock()
				
				#create basic setup with calc nodes
					#multipler
				fk_joints[-2].stretch >> globalMultiplier.input1X
				globalMultiplier.input2X.set(1)

				#add stretchy to the FK joints
				for j in fk_joints[1:]:
					jointMult = createNode('multiplyDivide')
					orig = j.translateX.get()
					jointMult.input1X.set(orig)
					j.translateX.unlock()
					globalMultiplier.outputX >> jointMult.input2X
					jointMult.outputX >> j.translateX
				
				
			#rename if there is only one anim
			if len(fk_joints) == 2:
				fk_joints[0].rename("%s_anim"%(compName))
				
			#for inc in xrange(len(bind_joints)-1):
			#	parentConstraint(fk_joints[inc], bind_joints[inc], w=1)
				
			#grouping
			zeroGrp = createZeroedOutGrp(fk_joints[0])
			select(cl=1)
			animGrp = group(zeroGrp, n = "%s_anim_grp"%compName)
			mainGrp = group([animGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
				
			#connectToMeta
			self.networkNode.setAttr('stretchy', stretchy,  f=1)
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
			connectChainToMeta(fk_joints, self.networkNode, 'FKJoints')
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			
			select(cl=1)
	
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
	
	
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.FKJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.FKJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("FKChain.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			fk_joints = self.networkNode.FKJoints.listConnections()
			for inc in xrange(len(fk_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return fk_joints[inc]
				if location == fk_joints[inc]:
					return fk_joints[inc]
		raise Exception("FKChain.getConnectObj: location wasn't found, try 'start', 'end', or name of bind or fk joint ")

	def isFK(self):
		return True
		
	def getAnims(self):
		'''
		returns all the anims associated with the FK chain
		'''
		return self.networkNode.FKJoints.listConnections()[:-1]
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		if other == self:
			for anim in self.getAnims():
				rot = anim.rotate.get()
				anim.rotate.set(-rot[0],-rot[1],rot[2])
			return [self]
		else:
			allAnims = self.getAnims()
			allRots = []
			map(lambda x: allRots.append(x.rotate.get()), allAnims)
			if bothSides:
				otherAnims = other.getAnims()
				otherRots = []
				map(lambda x: otherRots.append(x.rotate.get()), otherAnims)
				inc = 0
				for anim in allAnims:
					anim.rotate.set(otherRots[inc])
					inc += 1
				inc = 0
				for anim in otherAnims:
					anim.rotate.set(allRots[inc])
					inc+=1
				return [self, other]
			else:
				otherAnims = other.getAnims()
				otherRots = []
				map(lambda x: otherRots.append(x.rotate.get()), otherAnims)
				inc = 0
				for anim in allAnims:
					anim.rotate.set(otherRots[inc])
					inc += 1
				return [self]
				
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		return self.getAnims()
	
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''			
		anims = self.getAllAnims()
		for anim in anims:
			resetAttrs(anim)
			
class SingleIKChain(RigComponent):
	def __init__(self, side, bodyPart, startJoint, endJoint, node = ''):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'SingleIKChain'):
					self.networkNode = node
				else:
					printError("SingleIKChain: node %s is not a SingleIKChain metaNode"%(node))
			else:
				printError("SingleIKChain: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'SingleIKChain', 1.0, 'singlechain(SC) IK solver chain', side, bodyPart, startJoint, endJoint)
			chain = chainBetween(startJoint, endJoint)
			bind_joints = []
			compName = '%s_%s'%(side, bodyPart)
			for item in chain:
				item = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
					
			ik_joints = duplicateChain(bind_joints[0],bind_joints[-1], 'bind', 'IK')
			
			anims = []
			zeroGrps = []
			for inc in xrange(len(ik_joints)-1):
				base = ik_joints[inc]
				top = ik_joints[inc+1]
				#create Anim
				select(clear=1)
				anim = joint(n = '%s_%i_anim'%(compName, inc+1))
				alignPointOrient(top, anim, 1,1)
				zeroGrp = createZeroedOutGrp(anim)
				addAnimAttr(anim)
				cube = polyCube()[0]
				appendShape(cube, anim)
				delete(cube)
				parentConstraint(anim, top, w=1)
				lockAndHideAttrs(anim, ['sx','sy','sz','v','radius'])
				zeroGrps.append(zeroGrp)
				anims.append(anim)
				
			#rename if there is only one anim
			if len(ik_joints) == 2:
				anims[0].rename("%s_anim"%(compName))
				
			for inc in xrange(len(bind_joints)-1):#not the first joint
				parentConstraint(ik_joints[inc+1], bind_joints[inc+1], w=1)
				
			#grouping
			select(cl=1)
			animGrp = group(zeroGrps, n="%s_anim_grp"%compName)
			jointGrp = group(ik_joints[0], n = "%s_joint_grp"%compName)
			mainGrp = group([animGrp, jointGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
				
			#connectToMeta
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
			connectChainToMeta(ik_joints, self.networkNode, 'IKJoints')
			connectChainToMeta(anims, self.networkNode, 'anims' )
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			
			select(cl=1)
	
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
		
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.IKJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.IKJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("SingleIKChain.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			ik_joints = self.networkNode.IKJoints.listConnections()
			for inc in xrange(len(ik_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return ik_joints[inc]
				if location == ik_joints[inc]:
					return ik_joints[inc]
		raise Exception("FKChain.getConnectObj: location wasn't found, try 'start', 'end', or name of bind or ik joint ")

	def isIK(self):
		return True
		
	def getAnims(self):
		'''
		returns all the anims associated with the FK chain
		'''
		return self.networkNode.anims.listConnections()
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		if other == self:  
			for anim in self.getAnims():
				rot = anim.rotate.get()
				anim.rotate.set(-rot[0],-rot[1],rot[2])
				anim.translateX.set(-anim.translateX.get())
			return [self]
		else:
			allAnims = self.getAnims()
			allRots = []
			allTrans = []
			map(lambda x: allRots.append(x.rotate.get()), allAnims)
			map(lambda x: allTrans.append(x.translate.get()), allAnims)
			if bothSides:
				otherAnims = other.getAnims()
				otherRots = []
				otherTrans = []
				map(lambda x: otherRots.append(x.rotate.get()), otherAnims)
				map(lambda x: otherTrans.append(x.translate.get()), otherAnims)
				inc = 0
				for anim in allAnims:
					anim.rotate.set(otherRots[inc])
					anim.translate.set(-otherTrans[inc])
					inc += 1
				inc = 0
				for anim in otherAnims:
					anim.rotate.set(allRots[inc])
					anim.translate.set(-allTrans[inc])
					inc+=1
				return [self, other]
			else:
				otherAnims = other.getAnims()
				otherRots = []
				map(lambda x: otherRots.append(x.rotate.get()), otherAnims)
				inc = 0
				for anim in allAnims:
					anim.rotate.set(otherRots[inc])
					anim.translate.set(-otherTrans[inc])
					inc += 1
				return [self]
				
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		return self.getAnims()
		
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''			
		anims = self.getAllAnims()
		for anim in anims:
			resetAttrs(anim)
			
class ReverseChain(RigComponent):
	
	def __init__(self, side, bodyPart, startJoint, endJoint, node = ''):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'ReverseChain'):
					self.networkNode = node
				else:
					printError("ReverseChain: node %s is not a ReverseChain metaNode"%(node))
			else:
				printError("ReverseChain: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'ReverseChain', 1.0, 'creates FK Joint that rotates from the Joints child Node', side, bodyPart, startJoint, endJoint)
			chain = chainBetween(startJoint, endJoint)
			compName = '%s_%s'%(side, bodyPart)
			bind_joints = []
			for item in chain:
				item = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
			if not len(bind_joints) == 2:
				raise Exception('ReverseChain.__init__: should only have 2 joints ')
			
			#create control chain
			control_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'control')
			
			
			#create reverse Joints
			select(cl=1)
			piv_pos = bind_joints[-1].getTranslation(space = 'world')
			rot_pos = bind_joints[0].getTranslation(space = 'world')
			rev_piv_joint = joint(p = piv_pos)
			rev_rot_joint = joint(p = rot_pos, n = "%s_rot_joint"%compName)
			joint(rev_piv_joint, e=1, zso=1, oj='xyz', sao='yup')
			
			#make pivot joint into anim
			addBoxToJoint(rev_piv_joint)
			lockAndHideAttrs(rev_piv_joint, ['tx', 'ty', 'tz', 'sx', 'sy', 'sz', 'v', 'radius'])
			addAnimAttr(rev_piv_joint)
			rev_piv_joint.rename('%s_anim'%compName)		
			
			#parent Constrain to control and bind joints
			parentConstraint(rev_rot_joint, control_joints[0],mo=1,w=1)
			
			for inc in xrange(len(bind_joints)-1):
				parentConstraint(control_joints[inc], bind_joints[inc])
			
			#grouping
			select(cl=1)
			jointGrp = group([control_joints[0], rev_piv_joint],n='%s_joint_grp'%compName)
			dntGrp = group(empty =1 , n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, dntGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
			
			#hide extra junk
			dntGrp.hide()
			control_joints[0].hide()
					
			
			#connect To Meta
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
			connectChainToMeta(control_joints, self.networkNode, 'controlJoints')
			connectToMeta(rev_rot_joint, self.networkNode, 'rotateJoint')
			connectToMeta(rev_piv_joint, self.networkNode, 'reverseAnim')
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			connectToMeta(dntGrp, self.networkNode, 'doNotTouchGrp')
			
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
		
		
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.controlJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.controlJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("ReverseChain.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			control_joints = self.networkNode.controlJoints.listConnections()
			for inc in xrange(len(fk_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return control_joints[inc]
				if location == control_joints[inc]:
					return control_joints[inc]
		raise Exception("ReverseChain.getConnectObj: location wasn't found, try 'start', 'end', or name of bind or control joint ")
		
	def isFK(self):
		return True
		
	def getAnim(self):
		'''
		returns the reverse anim
		'''
		return self.networkNode.reverseAnim.listConnections()[0]
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		if other == self:
			anim = self.getAnim()
			rot = anim.rotate.get()
			anim.rotate.set(-rot[0],-rot[1],rot[2])
			return [self]
		else:
			anim = self.getAnim()
			rot = anim.rotate.get()
			if bothSides:
				otherAnim = other.getAnim()
				otherRot = otherAnim.rotate.get()
				anim.rotate.set(otherRot)
				otherAnim.rotate.set(rot)
				return [self, other]
			else:
				otherAnim = other.getAnim()
				otherRot = otherAnim.rotate.get()
				anim.rotate.set(otherRot)
				return [self]
	
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		return [self.getAnim()]
		
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''			
		resetAttrs(self.getAnim())

class IKLips(RigComponent):
	def __init__(self,upperLeft, upperRight, lowerLeft, lowerRight, side, bodyPart,startJoint, endJoint, node = ''):
		'''
		upperLeft:
			the joints in the upper Left section of the mouth, starting from upperCenter
		upperRight:
			the joints in the upper Right sectio of the mouth, starting from upper Center
		lowerLeft:
			the joints in the lower left section of the mouth, starting from the lower center
		lowerRight:
			the joints in the lower right section of the mouth, starting from the lower center
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'IKLips'):
					self.networkNode = node
				else:
					printError("IKLips: node %s is not a IKLips metaNode"%(node))
			else:
				printError("IKLips: node %s doesn't exist"%(node))
		
		else:
			
			RigComponent.__init__(self, 'IKLips', 1.0, 'a ik component with tweaks for animating around a hole',side, bodyPart, startJoint, endJoint)
			compName = '%s_%s'%(side, bodyPart)
			
			#error testing
			upperRight = map(lambda x: PyNode(x), upperRight)
			upperLeft = map(lambda x: PyNode(x), upperLeft)
			lowerRight = map(lambda x: PyNode(x), lowerRight)
			lowerLeft = map(lambda x: PyNode(x), lowerLeft)
			
			#create initial groups
			jointGrp = group(empty = 1, n='%s_joint_grp'%compName)
			animGrp = group(empty = 1, n = "%s_anim_grp"%compName)
			dntGrp = group(empty =1, n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
			
			#hide some
			dntGrp.visibility.set(0)
			
			#make single ik chains for each joint
			allJoints = []
			tweakAnims = []
			orig_singleIKZeroGrps = {}
			for x in upperLeft:
				if not x in allJoints:
					allJoints.append(x)
			for x in upperRight:
				if not x in allJoints:
					allJoints.append(x)
			for x in lowerLeft:
				if not x in allJoints:
					allJoints.append(x)
			for x in lowerRight:
				if not x in allJoints:
					allJoints.append(x)
			for j in allJoints:
				ikChain = duplicateChain(j.getParent(), j)
				ikChainCompName = j.name().split("_bind_joint")[0] + "_tweak"
				ret = createSingleIKChain(ikChain[0],ikChain[-1], ikChainCompName)
				tweakAnims.append(ret[0][0])
				orig_singleIKZeroGrps[j] = ret[1]
				parent(ret[2], animGrp)
				parent(ret[4], jointGrp)
				#connect the bind joints to the ik joints
				parentConstraint(ret[3][-1],j, w=1, mo=1)
			
			#make ik spline chain for each joint section
			URikSplineJoints = []
			orig_nurbsJoint = {}
			for inc in xrange(len(upperRight)):
				select(cl=1)
				j = upperRight[inc]
				ikSplineJoint = joint(n = j.name().replace('bind', 'ik_dummy'))
				orig_nurbsJoint[j] = ikSplineJoint
				alignPointOrient( j, ikSplineJoint, 1,1)
				if URikSplineJoints:
					parent(ikSplineJoint, URikSplineJoints[inc-1])
				URikSplineJoints.append(ikSplineJoint)
			makeIdentity(URikSplineJoints[0], apply=1, t=0, r=1, s=0, n=0)
			joint(URikSplineJoints[0], e=1,oj= 'xyz', secondaryAxisOrient= 'yup', ch=1, zso=1);
			
			ULikSplineJoints = []
			for inc in xrange(len(upperLeft)):
				select(cl=1)
				j = upperLeft[inc]
				ikSplineJoint = joint(n = j.name().replace('bind', 'ik_dummy'))
				orig_nurbsJoint[j] = ikSplineJoint
				alignPointOrient( j, ikSplineJoint, 1,1)
				if ULikSplineJoints:
					parent(ikSplineJoint, ULikSplineJoints[inc-1])
				ULikSplineJoints.append(ikSplineJoint)
			makeIdentity(ULikSplineJoints[0], apply=1, t=0, r=1, s=0, n=0)
			joint(ULikSplineJoints[0], e=1,oj= 'xyz', secondaryAxisOrient= 'yup', ch=1, zso=1);
			
			LRikSplineJoints = []
			for inc in xrange(len(lowerRight)):
				select(cl=1)
				j = lowerRight[inc]
				ikSplineJoint = joint(n = j.name().replace('bind', 'ik_dummy'))
				orig_nurbsJoint[j] = ikSplineJoint
				alignPointOrient( j, ikSplineJoint, 1,1)
				if LRikSplineJoints:
					parent(ikSplineJoint, LRikSplineJoints[inc-1])
				LRikSplineJoints.append(ikSplineJoint)
			makeIdentity(LRikSplineJoints[0], apply=1, t=0, r=1, s=0, n=0)
			joint(LRikSplineJoints[0], e=1,oj= 'xyz', secondaryAxisOrient= 'yup', ch=1, zso=1);
			
			LLikSplineJoints = []
			for inc in xrange(len(lowerLeft)):
				select(cl=1)
				j = lowerLeft[inc]
				ikSplineJoint = joint(n = j.name().replace('bind', 'ik_dummy'))
				orig_nurbsJoint[j] = ikSplineJoint
				alignPointOrient( j, ikSplineJoint, 1,1)
				if LLikSplineJoints:
					parent(ikSplineJoint, LLikSplineJoints[inc-1])
				LLikSplineJoints.append(ikSplineJoint)
			makeIdentity(LLikSplineJoints[0], apply=1, t=0, r=1, s=0, n=0)
			joint(LLikSplineJoints[0], e=1,oj= 'xyz', secondaryAxisOrient= 'yup', ch=1, zso=1);

			#make the ikNurbs plane chain for the upper left
			ULret = createNurbsPlaneIKChain(ULikSplineJoints[0],ULikSplineJoints[-1] , 'upper_left_lips')
			ULstartAnim = ULret[0]   	#0, the ik anim that controls the start of the chain   
			ULmidAnim = ULret[1]		#1  the ik anim that controls the middle of the chain, note: parented contrained between start and end
			ULendAnim = ULret[2]		#2  the ik anim that controls the end of the chain
			parent(ULret[3], animGrp) # ret3 #animGrp,		#3  the grp created around the anims and their groups, note: reparent this group instead of the individual anims
			parent(ULret[4], jointGrp)
			parent(ULret[5], ULret[6], ULret[7], ULret[8], ULret[9], dntGrp)
			
			#make the ikNurbs plane chain for the upper right
			URret = createNurbsPlaneIKChain(URikSplineJoints[0],URikSplineJoints[-1] , 'upper_right_lips')
			URstartAnim = URret[0]   	#0, the ik anim that controls the start of the chain   
			URmidAnim = URret[1]		#1  the ik anim that controls the middle of the chain, note: parented contrained between start and end
			URendAnim = URret[2]
			parent(URret[3], animGrp) # ret3 #animGrp,		#3  the grp created around the anims and their groups, note: reparent this group instead of the individual anims
			parent(URret[4], jointGrp)
			parent(URret[5], URret[6], URret[7], URret[8], URret[9], dntGrp)
			
			#make the ikNurbs plane chain for the lower left
			LLret = createNurbsPlaneIKChain(LLikSplineJoints[0],LLikSplineJoints[-1] , 'lower_left_lips')
			LLstartAnim = LLret[0]   	#0, the ik anim that controls the start of the chain   
			LLmidAnim = LLret[1]		#1  the ik anim that controls the middle of the chain, note: parented contrained between start and end
			LLendAnim = LLret[2]
			parent(LLret[3], animGrp) # ret3 #animGrp,		#3  the grp created around the anims and their groups, note: reparent this group instead of the individual anims
			parent(LLret[4], jointGrp)
			parent(LLret[5], LLret[6], LLret[7], LLret[8], LLret[9], dntGrp)
			
			#make the ikNurbs plane chain for the lower right
			LRret = createNurbsPlaneIKChain(LRikSplineJoints[0],LRikSplineJoints[-1] , 'lower_right_lips')
			LRstartAnim = LRret[0]   	#0, the ik anim that controls the start of the chain   
			LRmidAnim = LRret[1]		#1  the ik anim that controls the middle of the chain, note: parented contrained between start and end
			LRendAnim = LRret[2]
			parent(LRret[3], animGrp) # ret3 #animGrp,		#3  the grp created around the anims and their groups, note: reparent this group instead of the individual anims
			parent(LRret[4], jointGrp)
			parent(LRret[5], LRret[6], LRret[7], LRret[8], LRret[9], dntGrp)
			
			#remove .animNode attributes from the ends of the nurbs anims
			URendAnim.animNode.delete()
			LRendAnim.animNode.delete()
			ULendAnim.animNode.delete()
			LLendAnim.animNode.delete()
			URstartAnim.animNode.delete()
			ULstartAnim.animNode.delete()
			LLstartAnim.animNode.delete()
			LRstartAnim.animNode.delete()
			
			#make extra anims for attaching corners and centers
				#right corner
			select(cl=1)
			rightMouthCornerAnim = joint(n = 'right_mouth_corner_anim')
			alignPointOrient(upperRight[-1], rightMouthCornerAnim, 1,1)
			rightMouthCornerZeroGrp = createZeroedOutGrp(rightMouthCornerAnim)
			addAnimAttr(rightMouthCornerAnim)
			cube = polyCube()[0]
			appendShape(cube, rightMouthCornerAnim)
			delete(cube)
			lockAndHideAttrs(rightMouthCornerAnim, [ 'v', 'radius', 'sx', 'sy', 'sz'])
			
				#left corner
			select(cl=1)
			leftMouthCornerAnim = joint(n = 'left_mouth_corner_anim')
			alignPointOrient(upperLeft[-1], leftMouthCornerAnim, 1,1)
			leftMouthCornerZeroGrp = createZeroedOutGrp(leftMouthCornerAnim)
			addAnimAttr(leftMouthCornerAnim)
			cube = polyCube()[0]
			appendShape(cube, leftMouthCornerAnim)
			delete(cube)
			lockAndHideAttrs(leftMouthCornerAnim, [ 'v', 'radius', 'sx', 'sy', 'sz'])
			
				#upper center
			select(cl=1)
			upperCenterAnim = joint(n = 'upper_lip_anim')
			alignPointOrient(upperLeft[0], upperCenterAnim, 1,1)
			upperCenterZeroGrp = createZeroedOutGrp(upperCenterAnim)
			addAnimAttr(upperCenterAnim)
			cube = polyCube()[0]
			appendShape(cube, upperCenterAnim)
			delete(cube)
			lockAndHideAttrs(upperCenterAnim, [ 'v', 'radius', 'sx', 'sy', 'sz'])
			
				#lower center
			select(cl=1)
			lowerCenterAnim = joint(n = 'lower_lip_anim')
			alignPointOrient(lowerLeft[0], lowerCenterAnim, 1,1)
			lowerCenterZeroGrp = createZeroedOutGrp(lowerCenterAnim)
			addAnimAttr(lowerCenterAnim)
			cube = polyCube()[0]
			appendShape(cube, lowerCenterAnim)
			delete(cube)
			lockAndHideAttrs(lowerCenterAnim, [ 'v', 'radius', 'sx', 'sy', 'sz'])
			
			#group main anims
			mainAnimGrp = group(upperCenterZeroGrp, lowerCenterZeroGrp, leftMouthCornerZeroGrp, rightMouthCornerZeroGrp, n= '%s_main_anims')
			parent(mainAnimGrp, animGrp)
			
			#make extra anims control other anims
				#right mouth corner
			parentConstraint(rightMouthCornerAnim, URendAnim, w=1, mo=1)
			parentConstraint(rightMouthCornerAnim, LRendAnim, w=1, mo=1)
			URendAnim.visibility.unlock()
			LRendAnim.visibility.unlock()
			URendAnim.visibility.set(0)
			LRendAnim.visibility.set(0)
			
				#left mouth corner
			parentConstraint(leftMouthCornerAnim, ULendAnim, w=1, mo=1)
			parentConstraint(leftMouthCornerAnim, LLendAnim, w=1, mo=1)
			ULendAnim.visibility.unlock()
			LLendAnim.visibility.unlock()
			ULendAnim.visibility.set(0)
			LLendAnim.visibility.set(0)
			
				#upper center
			parentConstraint(upperCenterAnim, URstartAnim, w=1, mo=1)
			parentConstraint(upperCenterAnim, ULstartAnim, w=1, mo=1)
			URstartAnim.visibility.unlock()
			ULstartAnim.visibility.unlock()
			URstartAnim.visibility.set(0)
			ULstartAnim.visibility.set(0)
				
				#lower center
			parentConstraint(lowerCenterAnim, LRstartAnim, w=1, mo=1)
			parentConstraint(lowerCenterAnim, LLstartAnim, w=1, mo=1)
			LLstartAnim.visibility.unlock()
			LRstartAnim.visibility.unlock()
			LLstartAnim.visibility.set(0)
			LRstartAnim.visibility.set(0)
			
			#connect the nurbs to the single IK
			for j in allJoints:
				zeroGrp = orig_singleIKZeroGrps[j]
				nurbsJoint = orig_nurbsJoint[j]
				parentConstraint(nurbsJoint, zeroGrp, w=1, mo=1)
			
			
			#connectToMeta
			connectChainToMeta(allJoints, self.networkNode, 'bindJoints')
			connectToMeta(lowerCenterAnim, self.networkNode, 'lowerLipAnim')
			connectToMeta(upperCenterAnim, self.networkNode, 'upperLipAnim')
			connectToMeta(rightMouthCornerAnim, self.networkNode, 'rightMouthCornerAnim')
			connectToMeta(leftMouthCornerAnim, self.networkNode, 'leftMouthCornerAnim')
			connectToMeta(URmidAnim ,self.networkNode, 'upperRightMidAnim')
			connectToMeta(LRmidAnim ,self.networkNode, 'lowerRightMidAnim')
			connectToMeta(ULmidAnim ,self.networkNode, 'upperLeftMidAnim')
			connectToMeta(LLmidAnim ,self.networkNode, 'lowerLeftMidAnim')
			connectChainToMeta(tweakAnims, self.networkNode, 'tweakAnims')
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			connectToMeta(jointGrp, self.networkNode, 'jointGrp')
			connectToMeta(dntGrp, self.networkNode, 'dntGrp')
			connectToMeta(animGrp, self.networkNode, 'animGrp')
		
	def getAllTweakAnims(self):
		allTweaks = self.networkNode.tweakAnims.listConnections()
		return allTweaks
	
	
	def getAllMainAnims(self):
		allMain = []
		allMain.append(self.networkNode.lowerLipAnim.listConnections()[0])
		allMain.append(self.networkNode.upperLipAnim.listConnections()[0])
		allMain.append(self.networkNode.rightMouthCornerAnim.listConnections()[0])
		allMain.append(self.networkNode.leftMouthCornerAnim.listConnections()[0])
		allMain.append(self.networkNode.upperRightMidAnim.listConnections()[0])
		allMain.append(self.networkNode.lowerRightMidAnim.listConnections()[0])
		allMain.append(self.networkNode.upperLeftMidAnim.listConnections()[0])
		allMain.append(self.networkNode.lowerLeftMidAnim.listConnections()[0])
		return allMain
	
	def getAllAnims(self):
		allAnims = []
		map(lambda x: allAnims.append(x), self.getAllTweakAnims() )
		map(lambda x: allAnims.append(x), self.getAllMainAnims() )
		return allAnims
		
	def connectToComponentWithLevel(self, obj, anims):
		'''
		helper method to connectToComponent for only parenting part of the component
		'''
		dntGrp = self.networkNode.dntGrp.listConnections()[0]
		for x in anims:
			zero = createZeroedOutGrp(x)
			parentGrp = group(empty=1)
			parent(parentGrp, dntGrp)
			alignPointOrient(x, parentGrp, 1, 1)
			createZeroedOutGrp(parentGrp)
			parentConstraint(obj, parentGrp, w=1, mo=1)
			if 'mid' in x.name():#NOT THE BEST CHECK FOR MIDDLE NURBS ANIMS
				transMult = createNode('multiplyDivide')
				transMult.input2.set([.5,.5,.5])
				parentGrp.translate >> transMult.input1
				transMult.output >> zero.translate
				rotMult = createNode('multiplyDivide')
				rotMult.input2.set([.5,.5,.5])
				parentGrp.translate >> rotMult.input1
				rotMult.output >> zero.rotate
			else:
				parentGrp.translate >> zero.translate
				parentGrp.rotate >> zero.rotate
		
	def connectToComponent(self, comp, location, point=1, orient =1, level = 'all'):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []
		
		
		if level == 'all':
			mainGrp.setPivots(obj.getTranslation(space= 'world'))
			parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		elif level == 'upper':
			anims = []
			anims.append(self.networkNode.upperRightMidAnim.listConnections()[0])
			anims.append(self.networkNode.upperLipAnim.listConnections()[0])
			anims.append(self.networkNode.upperLeftMidAnim.listConnections()[0])
			self.connectToComponentWithLevel(obj, anims)
		elif level == 'lower':
			anims = []
			anims.append(self.networkNode.lowerRightMidAnim.listConnections()[0])
			anims.append(self.networkNode.lowerLipAnim.listConnections()[0])
			anims.append(self.networkNode.lowerLeftMidAnim.listConnections()[0])
			self.connectToComponentWithLevel(obj, anims)
		elif level == 'mid':#corner
			anims = []
			anims.append(self.networkNode.rightMouthCornerAnim.listConnections()[0])
			anims.append(self.networkNode.rightMouthCornerAnim.listConnections()[0])
			self.connectToComponentWithLevel(obj, anims)
	
	
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.rightMouthCornerAnim.listConnections()[0]
		elif location == 'end':
			return self.networkNode.leftMouthCornerAnim.listConnections()[0]
		else: # an object
			if not objExists(location):
				raise Exception("FKChain.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			for inc in xrange(len(fk_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return bind_joints[inc]
				if location == fk_joints[inc]:
					return bind_joints[inc]
		raise Exception("FKChain.getConnectObj: location wasn't found, try 'start', 'end', or name of bind or fk joint ")
		
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''		
		anims = self.getAllAnims()
		for anim in anims:
			resetAttrs(anim)
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		printWarning("IKLips.mirror: not yet implemented")
		
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		if other == self:
			anim = self.getAnim()
			anim.rotateX.set(anim.rotateX.get()*-1)
			anim.rotateY.set(anim.rotateY.get()*-1)
			return [self]
		else:
			anim = self.getAnim()
			attrs = anim.listAttr(keyable = 1)
			attrValue = {}
			attrs = map(lambda x: x.name().split(".")[-1], attrs)
			for x in attrs:
				attrValue[x] = anim.attr(x).get()
			otherAnim = other.getAnim()
			otherAttrs = otherAnim.listAttr(keyable = 1)
			otherAttrs = map(lambda x: x.name().split(".")[-1], otherAttrs)
			otherAttrValue = {}	
			for x in otherAttrs:
				otherAttrValue[x] = otherAnim.attr(x).get()
			if bothSides:
				for attr in attrs:
					otherAnim.attr(attr).set(attrValue[attr])
				for attr in otherAttrs:
					anim.attr(attr).set(otherAttrValue[attr])
				return [self, other]
			else:
				for attr in otherAttrs:
					anim.attr(attr).set(otherAttrValue[attr])
			return [self]
		'''


class IKSplineChain(RigComponent):
	def __init__(self, side, bodyPart, startJoint, endJoint):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		RigComponent.__init__(self, 'IKChain', 1.0, 'chain of IK joints', side, bodyPart, startJoint, endJoint)
		chain = chainBetween(startJoint, endJoint)
		compName = '%s_%s'%(side, bodyPart)
		bind_joints = []
		for item in chain:
			item = PyNode(item)
			if item.type() == 'joint':
				bind_joints.append(item)
		ik_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'ik')
		
		#create ik handle/curve
		ik = ikHandle(sol='ikSplineSolver', ns = len(bind_joints), sj = ik_joints[0], ee = ik_joints[-1])[0]
		ik.rename('%s_ik'%compName)
		ikCurve = PyNode(ikHandle(ik, q=1, c=1)).getParent()
		ikCurve.rename('%s_ik_curve'%compName)
		ikCurve.inheritsTransform.set(0)
		
		#spine curve and anim setup
		select(cl=1)
		cvsJoint = joint(n = '%s_ik_curve_start_joint'%compName)
		select(cl=1)
		cvmJoint = joint(n = '%s_ik_curve_mid_joint'%compName)
		select(cl=1)
		cveJoint = joint(n = '%s_ik_curve_end_joint'%compName)
		
		alignPointOrient(ik_joints[0],cvsJoint,1,1 )
		alignPointOrient(ik_joints[len(ik_joints)/2],cvmJoint,1,1 )
		alignPointOrient(ik_joints[-1],cveJoint,1,1 )
		
		curve_joints = [cvsJoint, cvmJoint, cveJoint]
		anim_joints =[]
		spineLocs = []
		zeroGrps = []
		for obj in [cvsJoint,cveJoint]:			
			select(obj)
			animJoint = joint(n=obj.name().replace('ik_curve_','' ).replace('_joint','_anim'))
			addAnimAttr(animJoint)
			parent(animJoint, w=1)
			parent(obj, animJoint)
			zeroGrps.append(createZeroedOutGrp(animJoint))
			
			s = polySphere()[0]
			appendShape(s, animJoint)
			delete(s)
			anim_joints.append(animJoint)
			
			loc = spaceLocator(n = obj.name().replace('ik_curve_','' ).replace('_joint','_loc'))
			alignPointOrient(curve_joints[1], loc, 1,1)
			spineLocs.append(loc)
			
		midBendJoint = joint(n=cvmJoint.name().replace('ik_curve_','' ).replace('_joint','bend'))
		midBendJoint | cvmJoint 	
		
		parentConstraint(anim_joints[0], spineLocs[0], w=1,mo=1)
		parentConstraint(anim_joints[1], spineLocs[1], w=1, mo=1)
		parentConstraint(spineLocs, midBendJoint, w=1, mo=1)
		
		select(cvsJoint, cvmJoint, cveJoint, ikCurve)
		rt.SmoothBindSkin()
		
		#connect to bind joints
		for inc in xrange(len(bind_joints)-1):
			parentConstraint(ik_joints[inc], bind_joints[inc], w=1, mo=1)	
			
		#grouping
		select(cl=1)
		jointGrp = group([ik_joints[0], midBendJoint],n='%s_joint_grp'%compName)
		animGrp = group(zeroGrps, n = "%s_anim_grp"%compName)
		dntGrp = group([ik,ikCurve], n = "%s_DO_NOT_TOUCH_grp"%compName)
		parent(spineLocs, dntGrp)
		mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
		xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
		
		#hide
		dntGrp.hide()
		midBendJoint.hide()
		
		#connect To Meta
		connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
		connectChainToMeta(ik_joints, self.networkNode, 'IKJoints')
		connectToMeta(ikCurve, self.networkNode, 'ikCurve')
		connectToMeta(ik, self.networkNode, 'ikHandle')
		connectToMeta(anim_joints[0], self.networkNode, 'bottomAnim')
		connectToMeta(anim_joints[1], self.networkNode, 'topAnim')
		connectToMeta(mainGrp, self.networkNode, 'componentGrp')

	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
		
		
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.IKJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.IKJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("IKSpline.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			ik_joints = self.networkNode.IKJoints.listConnections()
			for inc in xrange(len(ik_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return ik_joints[inc]
				if location == ik_joints[inc]:
					return ik_joints[inc]
		raise Exception("ikSpline.getConnectObj: location wasn't found, try 'start', 'end', or name of bind or ik joint ")
	
	def isIK(self):
		return True
	
	def getIK(self):
		'''
		returns the ikhandle of the component
		'''
		return self.networkNode.ikHandle.listConnections()[0]
		
class AdditionalTwist(RigComponent):
	def __init__(self, twistLoc, side, bodyPart, startJoint, endJoint, node = ''):
		'''
		twistLoc:
			the place where the joints should twist from , start mid end
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'AdditionalTwist'):
					self.networkNode = node
				else:
					printError("AdditionalTwist: node %s is not a AdditionalTwist metaNode"%(node))
			else:
				printError("AdditionalTwist: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'AdditionalTwist', 1.0, 'chain that adds extra joints between two joints', side, bodyPart, startJoint, endJoint)
			compName = '%s_%s'%(side, bodyPart)
			
			#error test		
			chain =  chainBetween(startJoint, endJoint)
			numAdded = len(chain)-2
			control_joints = map(lambda x: PyNode(x), chain)
			twist_joints = duplicateChain(control_joints[0], control_joints[-1], 'bind', 'twist')
			
			#parent twist joints to world
			#stops inheritance of rotation
			for j in twist_joints:
				try:
					parent(j, world = 1)
				except:
					pass
			
			#twist anim
			select(cl=1)
			twistAnim = joint(n = compName + '_twist_anim')
			addAnimAttr(twistAnim)
			
			cube = polyCube()[0]
			appendShape(cube, twistAnim)
			delete(cube)
			zeroGrp = createZeroedOutGrp(twistAnim)
			#create twist grp, 
			twistGrp = group(empty = 1, n = "%s_twist_grp"%compName)
			
			
			
			if twistLoc == 'start':
				#place anim
				const = parentConstraint(twist_joints[0],twistAnim, w=1, mo=0)
				delete(const)
				makeIdentity(twistAnim, apply=1, t=0, r=1, s=1, n=0)
				#add rotation
				inc = numAdded+1
				while inc >= 0:
					multiplier = 1-(1.0/(numAdded+1))*inc
					mult = createNode('multiplyDivide')
					twistGrp.rotate >> mult.input1
					mult.input2.set([multiplier,multiplier, multiplier])
					mult.output >> twist_joints[inc].rotate
					inc -= 1
			elif twistLoc == 'mid':
				
				odd = len(twist_joints) % 2
				
				mid_start = int((len(twist_joints)+1)/2)-1#mid to start joint inc
				mid_end = int((len(twist_joints)+1)/2)-1 #mid to end joint inc
				
				if not odd:
					mid_end += 1
				
				#place anim
				const = parentConstraint(twist_joints[mid_start],twist_joints[mid_end], twistAnim, w=1, mo=0)
				delete(const)
				makeIdentity(twistAnim, apply=1, t=0, r=1, s=1, n=0)
				
				div = mid_start
				inc = mid_start
				while inc >= 0:
					multiplier = float(inc)/div
					
					mult = createNode('multiplyDivide')
					twistGrp.rotate >> mult.input1
					mult.input2.set([multiplier,multiplier, multiplier])
					mult.output >> twist_joints[mid_start].rotate
					mult.output >> twist_joints[mid_end].rotate
					
					mid_start -=1
					mid_end += 1
					inc -= 1
			elif twistLoc == 'end':
				#place anim
				const = parentConstraint(twist_joints[-1],twistAnim, w=1, mo=0)
				delete(const)
				makeIdentity(twistAnim, apply=1, t=0, r=1, s=1, n=0)
				#add rotation
				inc = numAdded+1
				while inc > 0:
					multiplier = (1.0/(numAdded+1))*inc
					mult = createNode('multiplyDivide')
					twistGrp.rotate >> mult.input1
					mult.input2.set([multiplier,multiplier, multiplier])
					mult.output >> twist_joints[inc].rotate
					inc -= 1
					
			else: #not an option
				raise Exception("AdditionalTwist.__init__: please specify a twist location: 'end', 'mid', 'start'")
				
			#parentConstrain the twist to the control
			for inc in xrange(len(twist_joints)):
				parentConstraint(twist_joints[inc], control_joints[inc], w=1, mo=1)
				
			#lock anim attrs
			lockAndHideAttrs(twistAnim, ['tx', 'ty','tz', 'ry', 'rz','sx','sy','sz','v','radius'])
			
			#grouping
			select(cl=1)
			twistJointGrp = group(twist_joints, n = '%s_twist_joint_grp'%compName)
			jointGrp = group([twistJointGrp, control_joints[0]],n='%s_joint_grp'%compName)
			animGrp = group([zeroGrp], n = "%s_anim_grp"%compName)
			dntGrp = group(twistGrp, n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = control_joints[0].getTranslation(space = 'world'), ws=1)
			
			alignPointOrient(twistAnim, twistGrp, 1,1)
			twistZeroGrp = createZeroedOutGrp(twistGrp)
			parentConstraint(twistAnim, twistGrp, mo=1, w=1)
			
			#hide extra junk
			dntGrp.hide()
			twistJointGrp.hide()
			
			
			#connections to meta
			connectChainToMeta(twist_joints, self.networkNode, 'twistJoints')
			connectToMeta(twistAnim, self.networkNode, 'twistAnim')
			connectChainToMeta(control_joints, self.networkNode, 'bindJoints')
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			
			#add to meta
			self.networkNode.setAttr('twistFrom', twistLoc , f=1)
	
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
		
		
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.bindJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.bindJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("AdditionalTwist.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = [self.networkNode.startJoint.listConnections()[0],self.networkNode.endJoint.listConnections()[0]]
			control_joints = self.networkNode.bindJoints.listConnections()
			twist_joints = self.networkNode.twistJoints.listConnections()
			for inc in xrange(len(fk_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return control_joints[inc]
				if location == control_joints[inc]:
					return control_joints[inc]
				if location == twist_joints[inc]:
					return control_joints[inc]
		raise Exception("AdditionalTwist.getConnectObj: location wasn't found, try 'start', 'end', or name of bind twist or control joint ")
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		
		anim = self.getTwistAnim()
		animRot = anim.rotateX.get()
		if other == self:
			anim.rotateX.set(-animRot)
			return [self]
		else:
			otherAnim = other.getTwistAnim()
			otherRot = otherAnim.rotateX.get()
			if bothSides:
				otherAnim.rotateX.set(-animRot)
				anim.rotateX.set(-otherRot)
				return [self, other]
			else:
				anim.rotateX.set(-otherRot)
				return [self]	
	
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		return [self.getTwistAnim()]
		
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''			
		anim = self.getTwistAnim()
		resetAttrs(anim)
									
	def twistConstraint(self, constObject, axis = 'X'):
		'''
		tells which obect controls the twist of the additional twist t
		used well for automatic forearm twist
		'''
		anim = self.getTwistAnim()
		twist_grp = group(empty = 1, n = "%s_auto_twist_grp"%anim.name())
		par = anim.getParent()
		parent(twist_grp, par)
		alignPointOrient(anim, twist_grp,1,1)
		makeIdentity(twist_grp, apply=1, t=1, r=0,s=0, n=0)
		for x in ["translateX", "translateY", "translateZ"]:
			anim.attr(x).unlock()
		parent(anim, twist_grp)
		for x in ["translateX", "translateY", "translateZ"]:
			anim.attr(x).lock()
		
		orientConstraint(constObject, twist_grp, skip = ('y','z'), mo=1, w=1)
									
	def getTwistAnim(self):
		"""
		returns the twist anim
		"""
		return self.networkNode.twistAnim.listConnections()[0]
		
		
class FKIKSplineChain(RigComponent):
	def __init__(self, side, bodyPart, startJoint, endJoint, node = '', controlEnd = 0): #controlEnd is current hack to see if bindjoint parentConstraint should be on last joints, usually shouldn;t
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'FKIKSplineChain'):
					self.networkNode = node
				else:
					printError("FKIKSplineChain: node %s is not a FKIKSplineChain metaNode"%(node))
			else:
				printError("FKIKSplineChain: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'FKIKSplineChain', 1.0, 'spline chain of IK joints with fk switching', side, bodyPart, startJoint, endJoint)
			chain = chainBetween(startJoint, endJoint)
			compName = '%s_%s'%(side, bodyPart)
			bind_joints = []
			for item in chain:
				item = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
			#create chains
			ik_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'ik')
			fk_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'fk')
			control_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'control')
			
			#create FK
			for inc in xrange(len(fk_joints)-1):
				obj = fk_joints[inc]
				addBoxToJoint(obj)
				lockAndHideAttrs(obj, ['tx', 'ty', 'tz', 'sx', 'sy', 'sz', 'radius'])
				obj.v.set(keyable = 0)
				addAnimAttr(obj)
				obj.rename('%s_%i_anim'%(compName, inc+1))
			
			returns = createNurbsPlaneIKChain(ik_joints[0], ik_joints[-1], compName)
			startAnim = returns[0]
			midAnim = returns[1]		
			endAnim = returns[2]		
			animGrp = returns[3]		
			ik_joints_grp = returns[4] 	
			nurbsPlane = returns[5] 	
			transGrp = returns[6] 		
			dummyGrp = returns[7] 		
			ikLocGrp = returns[8]		
			distDimGrp = returns[9]		
			
			control_joint_grp = group(control_joints[0], n = '%s_control_joints'%compName)
			for cj in control_joints[1:]:
				control_joint_grp | cj
			
			select(cl=1)
			switchGroup = group(n = '%s_FKIK_switch'%compName)
			switchGroup.addAttr('FKIK_switch', keyable = 1)
			switchGroup.FKIK_switch.setMax(1)
			switchGroup.FKIK_switch.setMin(0)
			switchGroup.FKIK_switch.setKeyable(1)
			rev = createNode('reverse')
			switchGroup.FKIK_switch >> rev.inputX
			#set up control joint constraints
			for inc in xrange(len(control_joints)):
				constpar = parentConstraint(fk_joints[inc], ik_joints[inc], control_joints[inc])
				constscl = scaleConstraint(fk_joints[inc], ik_joints[inc], control_joints[inc], skip=['y','z'])
				rev.outputX >> constpar.w0
				rev.outputX >> constscl.w0
				switchGroup.FKIK_switch >> constpar.w1
				switchGroup.FKIK_switch >> constscl.w1
			lockAndHideAttrs(switchGroup, ('tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'sx', 'sy','sz','v'))
			
			#switch groups hide FK or IK
			rev.outputX >> fk_joints[0].visibility
			switchGroup.FKIK_switch >> animGrp.visibility 
			
			#connect to bind joints
			allowSafeScale(bind_joints[0], bind_joints[-1])
			range= len(bind_joints)-1
			if controlEnd:
				range = len(bind_joints)
			for inc in xrange(range):
				parentConstraint(control_joints[inc], bind_joints[inc], w=1, mo=1)
				#scaleConstraint(control_joints[inc], bind_joints[inc], w=1, mo=1, skip = ['y','z'])
				
				
			#grouping
			select(cl=1)
			jointGrp = group([ik_joints_grp, fk_joints[0], control_joint_grp],n='%s_joint_grp'%compName)
			dntGrp = group([nurbsPlane,	transGrp,dummyGrp,ikLocGrp,	distDimGrp,switchGroup], n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
			
			#hide
			switchGroup.FKIK_switch.set(1)
			
			dntGrp.hide()
			switchGroup.FKIK_switch >> ik_joints[0].v
			
			
			#connect To Meta
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
			connectChainToMeta(ik_joints, self.networkNode, 'IKJoints')
			connectChainToMeta(fk_joints, self.networkNode, 'FKJoints')
			connectChainToMeta(control_joints, self.networkNode, 'controlJoints')
			connectToMeta(startAnim, self.networkNode, 'startAnim')
			connectToMeta(midAnim, self.networkNode, 'midAnim')
			connectToMeta(endAnim, self.networkNode, 'endAnim')
			connectToMeta(switchGroup, self.networkNode, 'switchGroup')
			self.networkNode.setAttr('switchAttr', 'FKIK_switch', f=1)
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			
			
	def alignSwitch(self):
		#NOT TRULY IMPLEMENTED
		switchGroup = listConnections(self.networkNode.switchGroup)[0]	
		switchAttr = self.networkNode.switchAttr.get()
		attr = switchGroup.attr(switchAttr)
		attr.set(1-attr.get())
		
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []   
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
   
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.controlJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.controlJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("FKIKSPlineChain.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			control_joints = self.networkNode.controlJoints.listConnections()
			for inc in xrange(len(control_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return control_joints[inc]
		raise Exception("FKIKSplineChain.getConnectObj: location wasn't found, try 'start', 'end', or name of bind or fk joint ")
	
	def getAllAnims(self):
		allAnims = []
		allAnims.append(self.networkNode.startAnim.listConnections()[0])
		allAnims.append(self.networkNode.midAnim.listConnections()[0])
		allAnims.append(self.networkNode.endAnim.listConnections()[0])
		allAnims.append(self.networkNode.switchGroup.listConnections()[0])
		map(lambda x: allAnims.append(x), self.networkNode.FKJoints.listConnections()[:-1])
		return allAnims

	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''		
		anims = []
		anims.append(self.networkNode.startAnim.listConnections()[0])
		anims.append(self.networkNode.midAnim.listConnections()[0])
		anims.append(self.networkNode.endAnim.listConnections()[0])
		map(lambda x: anims.append(x), self.networkNode.FKJoints.listConnections()[:-1])
		for anim in anims:
			resetAttrs(anim)
			
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		printWarning("FKIKSplineChain.mirror: not yet implemented")
		
		
class FKIKSpine(RigComponent):
	def __init__(self, side, bodyPart, startJoint, endJoint, node = ''):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'FKIKSpine'):
					self.networkNode = node
				else:
					printError("FKIKSpine: node %s is not a FKIKSpine metaNode"%(node))
			else:
				printError("FKIKSpine: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'FKIKSpine', 1.0, 'has ik stretchy spine, and fk with pelvis', side, bodyPart, startJoint, endJoint)
			chain = chainBetween(startJoint, endJoint)
			compName = '%s_%s'%(side, bodyPart)
			bind_joints = []
			for item in chain:
				item = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
			#create chains
			ik_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'ik')
			rev_joints = duplicateChain(bind_joints[0], bind_joints[1], 'bind', 'reverse')
			fk_joints = duplicateChain(bind_joints[1], bind_joints[-1], 'bind', 'fk')
			fk_control_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'fk_control')
			control_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'control')
			
			
			#create FK
				#reverse
			returns = createReverseChain(rev_joints[0], rev_joints[1], side + "_pelvis")
			pelvis_anim = returns[0]
			pelvis_anim_grp = returns[1]
			pelvis_joint_grp = returns[2]
			
			
				#fk
			inc = 1
			for obj in fk_joints[:-1]:
				addBoxToJoint(obj)
				lockAndHideAttrs(obj, ['tx', 'ty', 'tz', 'sx', 'sy', 'sz', 'radius'])
				obj.v.set(keyable = 0)
				addAnimAttr(obj)
				obj.rename('%s_%i_anim'%(compName, inc))
				inc+=1
				
				#connect To FK_control
			
			parentConstraint(rev_joints[0], fk_control_joints[0], w=1, mo=1)
			inc=1
			for x in fk_joints[:-1]:
				parentConstraint(x,fk_control_joints[inc],w=1, mo=1)
				inc+=1
			
			#create IK
			returns = createNurbsPlaneIKChain(ik_joints[0], ik_joints[-1], compName)
			startAnim = returns[0]
			midAnim = returns[1]		
			endAnim = returns[2]		
			ik_animGrp = returns[3]		
			ik_joints_grp = returns[4] 	
			nurbsPlane = returns[5] 	
			transGrp = returns[6] 		
			dummyGrp = returns[7] 		
			ikLocGrp = returns[8]		
			distDimGrp = returns[9]		
			
			control_joint_grp = group(control_joints[0], n = '%s_control_joints'%compName)
			for cj in control_joints[1:]:
				control_joint_grp | cj
			
			select(cl=1)
			switchGroup = group(n = '%s_FKIK_switch'%compName)
			switchGroup.addAttr('FKIK_switch', keyable = 1)
			switchGroup.FKIK_switch.setMax(1)
			switchGroup.FKIK_switch.setMin(0)
			switchGroup.FKIK_switch.setKeyable(1)
			rev = createNode('reverse')
			switchGroup.FKIK_switch >> rev.inputX
			#set up control joint constraints
			for inc in xrange(len(control_joints)):
				constpar = parentConstraint(fk_control_joints[inc], ik_joints[inc], control_joints[inc])
				#constscl = scaleConstraint(fk_control_joints[inc], ik_joints[inc], control_joints[inc], skip=['y','z'])
				rev.outputX >> constpar.w0
				#rev.outputX >> constscl.w0
				switchGroup.FKIK_switch >> constpar.w1
				#switchGroup.FKIK_switch >> constscl.w1
			lockAndHideAttrs(switchGroup, ('tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'sx', 'sy','sz','v'))
			
			switchGroup.FKIK_switch >> ik_animGrp.visibility
			rev.outputX >> pelvis_anim_grp.visibility
			rev.outputX >> fk_joints[0].visibility
			
			#connect to bind joints
			allowSafeScale(bind_joints[0], bind_joints[-1])
			for inc in xrange(len(bind_joints)):
				parentConstraint(control_joints[inc], bind_joints[inc], w=1, mo=1)
				#scaleConstraint(control_joints[inc], bind_joints[inc], w=1, mo=1, skip = ['y','z']), test
				
				
			#grouping
			select(cl=1)
			jointGrp = group([ik_joints_grp, fk_joints[0], rev_joints[0], fk_control_joints[0],pelvis_joint_grp, control_joint_grp],n='%s_joint_grp'%compName)
			dntGrp = group([nurbsPlane,	transGrp,dummyGrp,ikLocGrp,	distDimGrp,switchGroup], n = "%s_DO_NOT_TOUCH_grp"%compName)
			animGrp = group(ik_animGrp, pelvis_anim_grp)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
			
			#hide
			switchGroup.FKIK_switch.set(1)
			
			dntGrp.hide()
			switchGroup.FKIK_switch >> ik_joints[0].v
			
			
			#connect To Meta
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
			connectChainToMeta(ik_joints, self.networkNode, 'IKJoints')
			connectChainToMeta(fk_joints, self.networkNode, 'FKJoints')
			connectToMeta(pelvis_anim, self.networkNode, 'pelvisAnim')
			connectChainToMeta(control_joints, self.networkNode, 'controlJoints')
			connectToMeta(startAnim, self.networkNode, 'startAnim')
			connectToMeta(midAnim, self.networkNode, 'midAnim')
			connectToMeta(endAnim, self.networkNode, 'endAnim')
			connectToMeta(switchGroup, self.networkNode, 'switchGroup')
			self.networkNode.setAttr('switchAttr', 'FKIK_switch', f=1)
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
	
	def alignSwitch(self):
		#NOT TRULY IMPLEMENTED
		switchGroup = listConnections(self.networkNode.switchGroup)[0]	
		switchAttr = self.networkNode.switchAttr.get()
		attr = switchGroup.attr(switchAttr)
		attr.set(1-attr.get())
	
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []   
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
   
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.controlJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.controlJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("FKIKSpine.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			control_joints = self.networkNode.controlJoints.listConnections()
			for inc in xrange(len(control_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return control_joints[inc]
		raise Exception("FKIKSpine.getConnectObj: location wasn't found, try 'start', 'end', or name of bind or fk joint ")
	
	def getAllAnims(self):
		allAnims = []
		allAnims.append(self.networkNode.startAnim.listConnections()[0])
		allAnims.append(self.networkNode.midAnim.listConnections()[0])
		allAnims.append(self.networkNode.endAnim.listConnections()[0])
		allAnims.append(self.networkNode.switchGroup.listConnections()[0])
		allAnims.append(self.networkNode.pelvisAnim.listConnections()[0])
		map(lambda x: allAnims.append(x), self.networkNode.FKJoints.listConnections()[:-1])
		return allAnims

	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''		
		anims = []
		anims.append(self.networkNode.startAnim.listConnections()[0])
		anims.append(self.networkNode.midAnim.listConnections()[0])
		anims.append(self.networkNode.endAnim.listConnections()[0])
		anims.append(self.networkNode.pelvisAnim.listConnections()[0])
		map(lambda x: anims.append(x), self.networkNode.FKJoints.listConnections()[:-1])
		for anim in anims:
			resetAttrs(anim)
			
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		printWarning("FKIKSpine.mirror: not yet implemented")
	
class FKIKChain(RigComponent):
	def __init__(self, side, bodyPart, startJoint, endJoint, node=''):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'FKIKChain'):
					self.networkNode = node
				else:
					printError("FKIKChain: node %s is not a FKIKChain metaNode"%(node))
			else:
				printError("FKIKChain: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'FKIKChain', 1.0, 'chain that can switch between Fk and IK', side, bodyPart, startJoint, endJoint)
			compName = '%s_%s'%(side, bodyPart)
			chain = chainBetween(startJoint, endJoint)
			bind_joints = []
			for item in chain:
				item  = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
					
			#create and connect ik, fk, control and bind joints to meta
			FK_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', "FK")
			control_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'control')
			IK_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', "IK")
			
			if FK_joints[0].name().endswith("1"):
				FK_joints[0].rename(FK_joints[0].name().replace("1", '', -1))
			
			#connect FK joints
			for obj in FK_joints[:-1]:
				addBoxToJoint(obj)
				lockAndHideAttrs(obj, ['tx', 'ty', 'tz', 'sx', 'sy', 'sz', 'radius'])
				obj.v.set(keyable = 0)
				addAnimAttr(obj)
				obj.rename(obj.name().replace('joint', 'anim'))
			
			#connect IK Joints
			
			#IKHandle
			buf = ikHandle(startJoint = IK_joints[0], endEffector = IK_joints[2], sol = 'ikRPsolver', w=1)
			ik = buf[0]
			ik.rename('%s_ik'%compName)
			eff = buf[1]
			eff.rename('%s_eff'%compName)
			
			
			#Ik anim
			select(cl=1)
			animJoint = joint()
			labels = getJointLabels(IK_joints[2])
			animJoint.rename("%s_%s_ik_anim"%(labels[0], labels[1]))
			addAnimAttr(animJoint)
			
			cube = polyCube()[0]
			appendShape(cube, animJoint)
			delete(cube)
			
			alignPointOrient(IK_joints[2], animJoint, 1,1)
			ikGrp = group(ik, n = "ik_anim_control_grp")
			pointConstraint(animJoint, ikGrp, w=1, mo=1)
			animJointGrp = createZeroedOutGrp(animJoint)
			animJoint.v.set(keyable = 0)
			orientConstraint(animJoint, IK_joints[-1], mo=1, w=1)
			
			
			#PV
			pvLoc = createPVLocator(FK_joints[0], FK_joints[1], FK_joints[2])
			labels = getJointLabels(IK_joints[1])
			select(cl=1)
			pvJoint = joint()
			pvJoint.rename("%s_%s_pv_anim"%(labels[0], labels[1]))
			sphere = polySphere()[0]
			appendShape(sphere, pvJoint)
			alignPointOrient(pvLoc, pvJoint, 1,0)
			alignPointOrient(IK_joints[1], pvJoint, 0,1)
			addAnimAttr(pvJoint)
			delete(pvLoc)
			delete(sphere)
			poleVectorConstraint(pvJoint, ik, w=1)
			pvJointGrp = createZeroedOutGrp(pvJoint)
			pvJoint.v.set(keyable = 0)
			
			
			#connect IK and FK to the control
			select(cl=1)
			switchGroup = group(n = '%s_FKIK_switch'%compName)
			switchGroup.addAttr('FKIK_switch', keyable = 1)
			switchGroup.FKIK_switch.setMax(1)
			switchGroup.FKIK_switch.setMin(0)
			switchGroup.FKIK_switch.setKeyable(1)
			rev = createNode('reverse')
			switchGroup.FKIK_switch >> rev.inputX
			for inc in xrange(len(FK_joints)):
				const = parentConstraint(FK_joints[inc], IK_joints[inc], control_joints[inc])	
				rev.outputX >> const.w0
				switchGroup.FKIK_switch >> const.w1
			lockAndHideAttrs(switchGroup, ('tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'sx', 'sy','sz','v'))
				
			#connect control joints to bind joints
			for inc in xrange(len(FK_joints)):#-1
				parentConstraint(control_joints[inc], bind_joints[inc])
			
			lockAndHideAttrs(animJoint, ['sx','sy','sz','radius'])
			lockAndHideAttrs(pvJoint, ['rx', 'ry', 'rz','sx','sy','sz','radius'])	
				
			#grouping
			select(cl=1)
			jointGrp = group([FK_joints[0], IK_joints[0], control_joints[0]],n='%s_joint_grp'%compName)
			animGrp = group([animJointGrp, pvJointGrp], n = "%s_anim_grp"%compName)
			animGrp.inheritsTransform.set(0)
			
			dntGrp = group([ikGrp, switchGroup], n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
			
			#hiding
			control_joints[0].hide()
			dntGrp.hide()
			switchGroup.FKIK_switch >> IK_joints[0].visibility
			rev.outputX >> FK_joints[0].visibility
			switchGroup.FKIK_switch >> pvJoint.v
			switchGroup.FKIK_switch >> animJoint.v
			
			
			#connections to meta
			connectToMeta(ik, self.networkNode, 'ikHandle')
			connectToMeta(pvJoint, self.networkNode, 'pvAnim')
			connectToMeta(animJoint, self.networkNode, 'ikAnim')
			connectToMeta(switchGroup, self.networkNode, 'switchGroup')		
			self.networkNode.setAttr('switchAttr', 'FKIK_switch',  f=1)
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			connectToMeta(dntGrp, self.networkNode, 'dntGrp')
			connectChainToMeta(FK_joints, self.networkNode, 'FKJoints')
			connectChainToMeta(IK_joints, self.networkNode, 'IKJoints')
			connectChainToMeta(control_joints, self.networkNode, 'controlJoints')
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
		
	def alignSwitch(self):
		'''
		toggle between FK and IK while keeping current joint placement
		'''
		switchGroup = listConnections(self.networkNode.switchGroup)[0]	
		switchAttr = self.networkNode.switchAttr.get()
		
		if switchGroup.attr(switchAttr).get() < .5:
			#snap ik to fk
			alignPointOrient(listConnections(self.networkNode.FKJoints[2])[0],listConnections(self.networkNode.ikAnim)[0], 1,1)
			pvLoc = createPVLocator(listConnections(self.networkNode.FKJoints[0])[0], listConnections(self.networkNode.FKJoints[1])[0], listConnections(self.networkNode.FKJoints[2])[0])
			alignPointOrient(pvLoc, listConnections(self.networkNode.pvAnim)[0], 1,0)
			alignPointOrient(listConnections(self.networkNode.IKJoints)[1], listConnections(self.networkNode.pvAnim)[0], 0,1)
			delete(pvLoc)
			switchGroup.attr(switchAttr).set(1)
			setKeyframe(switchGroup.attr(switchAttr), itt='spline' , ott = 'step')
			
		else:
			#snap fk to ik
			ikjs = self.networkNode.IKJoints.listConnections()
			fkjs = self.networkNode.FKJoints.listConnections()
			for inc in xrange(3):
				alignPointOrient(ikjs[inc],fkjs[inc], 0,1)
			switchGroup.attr(switchAttr).set(0)
			setKeyframe(switchGroup.attr(switchAttr), itt='spline' , ott = 'step')
			
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
			
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.controlJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.controlJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("FKIKChain.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			control_joints = self.networkNode.controlJoints.listConnections()
			fk_joints = self.networkNode.FKJoints.listConnections()
			ik_joints = self.networkNode.IKJoints.listConnections()
			for inc in xrange(len(bind_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return control_joints[inc]
				if location == control_joints[inc]:
					return control_joints[inc]
				if location == fk_joints[inc]:
					return control_joints[inc]
				if location == ik_joints[inc]:
					return control_joints[inc]
		raise Exception("FKIKChain.getConnectObj: location wasn't found, try 'start', 'end', or name of bind ,fk, ik, or control joint ")

	def isIK(self):
		return True
	
	def getIK(self):
		return self.networkNode.ikHandle.listConnections()[0]
		
	def isFK(self):
		return True

	def getIKAnim(self):
		'''
		returns the ik anim at the end of the IK chain
		'''
		return self.networkNode.ikAnim.listConnections()[0]
		
	def getPVAnim(self):
		'''
		returns the pole vector anim
		'''	
		return self.networkNode.pvAnim.listConnections()[0]
		
	def getFKAnims(self):
		'''
		returns all the FK anims
		'''
		return self.networkNode.FKJoints.listConnections()[:-1]
	
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		allAnims = []
		allAnims.append(self.getPVAnim())
		allAnims.append(self.getIKAnim())
		map(lambda x: allAnims.append(x), self.getFKAnims())
		return allAnims
		
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''
		anims = self.getAllAnims()
		for anim in anims:			
			resetAttrs(anim)	
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		switchGroup = self.networkNode.switchGroup.listConnections()[0]
		switchAttr = self.networkNode.switchAttr.get()
		fkikMode = switchGroup.attr(switchAttr).get() < .5#true if fk
		
		pvAnim = self.getPVAnim()
		pvTrans = pvAnim.translate.get()
		ikAnim = self.getIKAnim()
		ikTrans = ikAnim.translate.get()
		ikRot = ikAnim.rotate.get()
		fkAnims = self.getFKAnims()
		fkRots = map(lambda x: x.rotate.get(), fkAnims)
		if other == self:
			if fkikMode:
				map(lambda x: x.rotate.set(-x.rotate.get()[0],-x.rotate.get()[1],x.rotate.get()[2] ), fkAnims)
			else:	
				pvAnim.translate.set(pvTrans[0], pvTrans[1], -pvTrans[2])
				ikAnim.rotate.set(ikRot[0], ikRot[1], -ikRot[2])
				ikAnim.translate.set(ikTrans[0], ikTrans[1], -ikTrans[2])
				return [self]
		else:
			otherPvAnim = other.getPVAnim()
			otherPvTrans = otherPvAnim.translate.get()
			otherIkAnim = other.getIKAnim()
			otherIkTrans = otherIkAnim.translate.get()
			otherIkRot = otherIkAnim.rotate.get()
			otherFkAnims = other.getFKAnims()
			otherFkRots = map(lambda x: x.rotate.get(), otherFkAnims)
			otherSwitchGroup = other.networkNode.switchGroup.listConnections()[0]
			otherSwitchAttr = other.networkNode.switchAttr.get()
			other_fkikMode = otherSwitchGroup.attr(otherSwitchAttr).get() < .5#true if fk		
			if bothSides:
				#mirror self
				if not fkikMode == other_fkikMode:
					self.alignSwitch()
				if other_fkikMode:
					for num in xrange(len(otherFkAnims)):
						thisAnim = fkAnims[num]
						thisAnim.rotate.set(otherFkRots[num])
				else:
					try:
						pvAnim.translate.set(-otherPvTrans)
					except: pass
					try:
						ikAnim.translate.set(-otherIkTrans)
					except: pass
					try:
						ikAnim.rotate.set(otherIkRot)
					except: pass
				if not fkikMode == other_fkikMode:
					self.alignSwitch()
				#mirror other
				if not fkikMode == other_fkikMode:
					other.alignSwitch()
				if fkikMode:
					for num in xrange(len(fkAnims)):
						otherAnim = otherFkAnims[num]
						otherAnim.rotate.set(fkRots[num])
				else:
					try:
						otherPvAnim.translate.set(-pvTrans)
					except: pass
					try:
						otherIkAnim.translate.set(-ikTrans)
					except: pass
					try:
						otherIkAnim.rotate.set(ikRot)
					except: pass
				if not fkikMode == other_fkikMode:
					other.alignSwitch()
				return [self, other]
			else:
				#mirror self
				if not fkikMode == other_fkikMode:
					self.alignSwitch()
				if other_fkikMode:
					for num in xrange(len(otherFkAnims)):
						thisAnim = fkAnims[num]
						thisAnim.rotate.set(otherFkRots[num])
				else:
					try:
						pvAnim.translate.set(-otherPvTrans)
					except: pass
					try:
						ikAnim.translate.set(-otherIkTrans)
					except: pass
					try:
						ikAnim.rotate.set(otherIkRot)
					except: pass
				if not fkikMode == other_fkikMode:
					self.alignSwitch()
			return [self]

class FKIKArm(RigComponent):
	def __init__(self, side, bodyPart, startJoint, endJoint,stretchy = 0, node=''):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'FKIKArm'):
					self.networkNode = node
				else:
					printError("FKIKArm: node %s is not a FKIKArm metaNode"%(node))
			else:
				printError("FKIKArm: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'FKIKArm', 1.0, 'arm chain that can switch between Fk and IK', side, bodyPart, startJoint, endJoint)
			compName = '%s_%s'%(side, bodyPart)
			chain = chainBetween(startJoint, endJoint)
			bind_joints = []
			for item in chain:
				item  = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
					
			#error checking
			#num in joint chain need 4
					
			#create ik, fk, control joints
			FK_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', "FK")
			control_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'control')
			IK_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', "IK")
				#Rename
			for x in xrange(len(FK_joints)):
				FK_joints[x].rename("%s_%i_fk_joint"%(compName, x+1))
				IK_joints[x].rename("%s_%i_ik_joint"%(compName, x+1))
				control_joints[x].rename("%s_%i_control_joint"%(compName, x+1))
			
			#connect FK joints
			for obj in FK_joints[:-1]:
				addBoxToJoint(obj)
				lockAndHideAttrs(obj, [ 'tx','ty', 'tz', 'sx', 'sy', 'sz', 'radius'])
				obj.tx.set(keyable = 0)
				obj.v.set(keyable = 0)
				addAnimAttr(obj)
				obj.rename(obj.name().replace('joint', 'anim'))
			lockAndHideAttrs(FK_joints[1], ["ry", "rx"])
			
			#IKHandle
			buf = ikHandle(startJoint = IK_joints[0], endEffector = IK_joints[-2], sol = 'ikRPsolver', w=1)
			ik = buf[0]
			ik.rename('%s_ik'%compName)
			eff = buf[1]
			eff.rename('%s_eff'%compName)
			
			#Ik anim
			select(cl=1)
			animJoint = joint()
			labels = getJointLabels(IK_joints[2])
			animJoint.rename("%s_%s_ik_anim"%(labels[0], labels[1]))
			addAnimAttr(animJoint)
			
			cube = polyCube()[0]
			appendShape(cube, animJoint)
			delete(cube)
			
			alignPointOrient(IK_joints[2], animJoint, 1,1)
			ikGrp = group(ik, n = "ik_anim_control_grp")
			pointConstraint(animJoint, ikGrp, w=1, mo=1)
			animJointGrp = createZeroedOutGrp(animJoint)
			animJoint.v.set(keyable = 0)
			orientConstraint(animJoint, IK_joints[2], mo=1, w=1)
			
			
			#PV
			pvLoc = createPVLocator(FK_joints[0], FK_joints[1], FK_joints[2])
			labels = getJointLabels(IK_joints[1])
			select(cl=1)
			pvJoint = joint()
			pvJoint.rename("%s_%s_pv_anim"%(labels[0], labels[1]))
			sphere = polySphere()[0]
			appendShape(sphere, pvJoint)
			alignPointOrient(pvLoc, pvJoint, 1,0)
			alignPointOrient(IK_joints[1], pvJoint, 0,1)
			addAnimAttr(pvJoint)
			delete(pvLoc)
			delete(sphere)
			poleVectorConstraint(pvJoint, ik, w=1)
			pvJointGrp = createZeroedOutGrp(pvJoint)
			pvJoint.v.set(keyable = 0)
			
			#ik stretchyness
			startPoint = None
			globalMultiplier = createNode('multiplyDivide')
			distDim = None
			if stretchy:
				#get total distance
				totalLength = 0
				totalLength += IK_joints[1].translateX.get() #upper arm length
				totalLength += IK_joints[2].translateX.get() #lower arm length
				totalLength = abs(totalLength)
				#create way of keeping currnet distance
				startPoint = spaceLocator()
				startPoint.translate.set(3.3615,2.2215554,7.659)#random point
				endPoint = spaceLocator()
				endPoint.translate.set(2.84596,23.2155,0.3325)#random point
				distDim = distanceDimension(sp=startPoint.translate.get(),ep= endPoint.translate.get())
				distDim = PyNode(distDim)
				alignPointOrient(IK_joints[0], startPoint, 1,0)
				alignPointOrient(IK_joints[2], endPoint, 1,0)
				parent(endPoint, animJoint)
				
				#create basic setup with calc nodes
					#multipler
				
				
				globalMultiplier.input1X.set(totalLength)
				globalMultiplier.input2X.set(1)
				#still have to put topCon globalsclae input globalMultiplier.input2X
				
				ratio = createNode('multiplyDivide') #outputX = currentLength\(orig*globalScale)
				ratio.operation.set(2)#divide
				globalMultiplier.outputX >> ratio.input2X
				distDim.distance >> ratio.input1X
					#conditional
				condition = createNode('condition')
				ratio.outputX >> condition.firstTerm
				condition.secondTerm.set(1)
				condition.operation.set(2)#greater than, if current ratio > 1
				condition.colorIfFalseR.set(1)
				ratio.outputX >> condition.colorIfTrueR
				
				#add stretchy to the FK and IK joints
				for j in xrange(2):
					ikJoint = IK_joints[j+1] # want to use FK/IK_joints[1,2] 
					jointMult = createNode('multiplyDivide')
					orig = ikJoint.translateX.get()
					jointMult.input1X.set(orig)
					condition.outColorR >> jointMult.input2X
					jointMult.outputX >> ikJoint.translateX
			
			
			#connect IK and FK to the control
			select(cl=1)
			switchGroup = group(n = '%s_FKIK_switch'%compName)
			switchGroup.addAttr('FKIK_switch', keyable = 1)
			switchGroup.FKIK_switch.setMax(1)
			switchGroup.FKIK_switch.setMin(0)
			switchGroup.FKIK_switch.setKeyable(1)
			rev = createNode('reverse')
			switchGroup.FKIK_switch >> rev.inputX
			for inc in xrange(len(FK_joints)):
				const = parentConstraint(FK_joints[inc], IK_joints[inc], control_joints[inc])	
				rev.outputX >> const.w0
				switchGroup.FKIK_switch >> const.w1
			lockAndHideAttrs(switchGroup, ('tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'sx', 'sy','sz','v'))
				
			#connect control joints to bind joints
			for inc in xrange(len(FK_joints)):#-1
				parentConstraint(control_joints[inc], bind_joints[inc])
			
			lockAndHideAttrs(animJoint, ['sx','sy','sz','radius'])
			lockAndHideAttrs(pvJoint, ['rx', 'ry', 'rz','sx','sy','sz','radius'])	
				
			#grouping
			select(cl=1)
			jointGrp = group([FK_joints[0], IK_joints[0], control_joints[0]],n='%s_joint_grp'%compName)
			animGrp = group([animJointGrp, pvJointGrp], n = "%s_anim_grp"%compName)
			
			dntGrp = group([distDim, ikGrp, switchGroup], n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
			
			#hiding
			if stretchy:
				parent(startPoint, dntGrp)
			control_joints[0].hide()
			dntGrp.hide()
			switchGroup.FKIK_switch >> IK_joints[0].visibility
			rev.outputX >> FK_joints[0].visibility
			switchGroup.FKIK_switch >> pvJoint.v
			switchGroup.FKIK_switch >> animJoint.v
			animJointGrp.inheritsTransform.set(0)#allows the feet not to move when hip moves, if hip.
			
			#connections to meta
			connectToMeta(ik, self.networkNode, 'ikHandle')
			connectToMeta(pvJoint, self.networkNode, 'pvAnim')
			connectToMeta(animJoint, self.networkNode, 'ikAnim')
			connectToMeta(switchGroup, self.networkNode, 'switchGroup')		
			self.networkNode.setAttr('switchAttr', 'FKIK_switch',  f=1)
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			connectToMeta(dntGrp, self.networkNode, 'dntGrp')
			self.networkNode.setAttr('stretchy', stretchy,  f=1)
			connectChainToMeta(FK_joints, self.networkNode, 'FKJoints')
			connectChainToMeta(IK_joints, self.networkNode, 'IKJoints')
			connectChainToMeta(control_joints, self.networkNode, 'controlJoints')
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
			connectToMeta(globalMultiplier, self.networkNode, 'globalMultiplier')
	
	def getSwitchAttr(self):
		switchNode = self.networkNode.switchGroup.listConnections()[0]
		switchAttrName = self.networkNode.switchAttr.get()
		return switchNode.attr(switchAttrName)
		
	def alignSwitch(self):
		'''
		toggle between FK and IK while keeping current joint placement
		'''
		switchGroup = listConnections(self.networkNode.switchGroup)[0]	
		switchAttr = self.networkNode.switchAttr.get()
		
		if switchGroup.attr(switchAttr).get() < .5:
			#snap ik to fk
			alignPointOrient(listConnections(self.networkNode.FKJoints[2])[0],listConnections(self.networkNode.ikAnim)[0], 1,1)
			pvLoc = createPVLocator(listConnections(self.networkNode.FKJoints[0])[0], listConnections(self.networkNode.FKJoints[1])[0], listConnections(self.networkNode.FKJoints[2])[0])
			alignPointOrient(pvLoc, listConnections(self.networkNode.pvAnim)[0], 1,0)
			alignPointOrient(listConnections(self.networkNode.IKJoints)[1], listConnections(self.networkNode.pvAnim)[0], 0,1)
			delete(pvLoc)
			wrist_fk_joint = self.networkNode.FKJoints.listConnections()[-2]
			ik_anim = self.networkNode.ikAnim.listConnections()[0]
			alignPointOrient(wrist_fk_joint, ik_anim , 0,1)
			switchGroup.attr(switchAttr).set(1)
			setKeyframe(switchGroup.attr(switchAttr), itt='spline' , ott = 'step')
			
		else:
			#snap fk to ik
			ikjs = self.networkNode.IKJoints.listConnections()
			fkjs = self.networkNode.FKJoints.listConnections()
			for inc in xrange(4):
				if inc == 1 or inc == 2:
					fkjs[inc].translateX.unlock()
					fkjs[inc].translateX.set(ikjs[inc].translateX.get())
					fkjs[inc].translateX.lock()
				alignPointOrient(ikjs[inc],fkjs[inc], 0,1)
			switchGroup.attr(switchAttr).set(0)
			setKeyframe(switchGroup.attr(switchAttr), itt='spline' , ott = 'step')	
			
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
			
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.controlJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.controlJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("FKIKChain.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			control_joints = self.networkNode.controlJoints.listConnections()
			fk_joints = self.networkNode.FKJoints.listConnections()
			ik_joints = self.networkNode.IKJoints.listConnections()
			for inc in xrange(len(bind_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return control_joints[inc]
				if location == control_joints[inc]:
					return control_joints[inc]
				if location == fk_joints[inc]:
					return control_joints[inc]
				if location == ik_joints[inc]:
					return control_joints[inc]
		raise Exception("FKIKChain.getConnectObj: location wasn't found, try 'start', 'end', or name of bind ,fk, ik, or control joint ")

	def isIK(self):
		return True
	
	def getIK(self):
		return self.networkNode.ikHandle.listConnections()[0]
		
	def isFK(self):
		return True

	def getIKAnim(self):
		'''
		returns the ik anim at the end of the IK chain
		'''
		return self.networkNode.ikAnim.listConnections()[0]
		
	def getPVAnim(self):
		'''
		returns the pole vector anim
		'''	
		return self.networkNode.pvAnim.listConnections()[0]
		
	def getFKAnims(self):
		'''
		returns all the FK anims
		'''
		return self.networkNode.FKJoints.listConnections()[:-1]
	
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		allAnims = []
		allAnims.append(self.getPVAnim())
		allAnims.append(self.getIKAnim())
		map(lambda x: allAnims.append(x), self.getFKAnims())
		allAnims.append(self.networkNode.switchGroup.listConnections()[0])
		return allAnims
		
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''
		allAnims = []
		allAnims.append(self.getPVAnim())
		allAnims.append(self.getIKAnim())
		map(lambda x: allAnims.append(x), self.getFKAnims())
		for anim in allAnims:			
			resetAttrs(anim)	
		
	def parentUnder(self, obj):
		'''
		parent this rigComponent under the obj
		obj:
			object to parent under
		'''
		if not objExists(obj):
			raise Exception("RigComponent: can't parent under $s, obj doesn't exist"%obj)
		try:
			parent(self.networkNode.componentGrp.listConnections()[0], obj)
			root = getMetaRoot(obj, 'CharacterRig')
			if root:
				try:
					topCon = root.getTopCon()
					topCon.globalScale >> self.networkNode.globalMultiplier.listConnections()[0].input2X
					ikAnim = self.networkNode.ikAnim.listConnections()[0]
					zeroGrp = ikAnim.getParent()
					parentConstraint(topCon, zeroGrp, w=1, mo=1)
					scaleConstraint(topCon, zeroGrp, w=1, mo =1)
				except:
					pass
		except:
			raise Exception("%s.parentUnder: not implemeneted"%self.networkNode.metaType.get())
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		switchGroup = self.networkNode.switchGroup.listConnections()[0]
		switchAttr = self.networkNode.switchAttr.get()
		fkikMode = switchGroup.attr(switchAttr).get() < .5#true if fk
		
		pvAnim = self.getPVAnim()
		pvTrans = pvAnim.translate.get()
		ikAnim = self.getIKAnim()
		ikTrans = ikAnim.translate.get()
		ikRot = ikAnim.rotate.get()
		fkAnims = self.getFKAnims()
		fkRots = map(lambda x: x.rotate.get(), fkAnims)
		if other == self:
			if fkikMode:
				map(lambda x: x.rotate.set(-x.rotate.get()[0],-x.rotate.get()[1],x.rotate.get()[2] ), fkAnims)
			else:	
				pvAnim.translate.set(pvTrans[0], pvTrans[1], -pvTrans[2])
				ikAnim.rotate.set(ikRot[0], ikRot[1], -ikRot[2])
				ikAnim.translate.set(ikTrans[0], ikTrans[1], -ikTrans[2])
				return [self]
		else:
			otherPvAnim = other.getPVAnim()
			otherPvTrans = otherPvAnim.translate.get()
			otherIkAnim = other.getIKAnim()
			otherIkTrans = otherIkAnim.translate.get()
			otherIkRot = otherIkAnim.rotate.get()
			otherFkAnims = other.getFKAnims()
			otherFkRots = map(lambda x: x.rotate.get(), otherFkAnims)
			otherSwitchGroup = other.networkNode.switchGroup.listConnections()[0]
			otherSwitchAttr = other.networkNode.switchAttr.get()
			other_fkikMode = otherSwitchGroup.attr(otherSwitchAttr).get() < .5#true if fk		
			if bothSides:
				#mirror self
				if not fkikMode == other_fkikMode:
					self.alignSwitch()
				if other_fkikMode:
					for num in xrange(len(otherFkAnims)):
						thisAnim = fkAnims[num]
						if not thisAnim.rotateX.isLocked():
							thisAnim.rotateX.set(otherFkRots[num][0])
						if not thisAnim.rotateY.isLocked():
							thisAnim.rotateY.set(otherFkRots[num][1])
						if not thisAnim.rotateZ.isLocked():
							thisAnim.rotateZ.set(otherFkRots[num][2])
				else:
					try:
						pvAnim.translate.set(-otherPvTrans)
					except: pass
					try:
						ikAnim.translate.set(-otherIkTrans)
					except: pass
					try:
						ikAnim.rotate.set(otherIkRot)
					except: pass
				if not fkikMode == other_fkikMode:
					self.alignSwitch()
				#mirror other
				if not fkikMode == other_fkikMode:
					other.alignSwitch()
				if fkikMode:
					for num in xrange(len(fkAnims)):
						otherAnim = otherFkAnims[num]
						if not otherAnim.rotateX.isLocked():
							otherAnim.rotateX.set(fkRots[num][0])
						if not otherAnim.rotateY.isLocked():
							otherAnim.rotateY.set(fkRots[num][1])
						if not otherAnim.rotateZ.isLocked():
							otherAnim.rotateZ.set(fkRots[num][2])
				else:
					try:
						otherPvAnim.translate.set(-pvTrans)
					except: pass
					try:
						otherIkAnim.translate.set(-ikTrans)
					except: pass
					try:
						otherIkAnim.rotate.set(ikRot)
					except: pass
				if not fkikMode == other_fkikMode:
					other.alignSwitch()
				return [self, other]
			else:
				#mirror self
				if not fkikMode == other_fkikMode:
					self.alignSwitch()
				if other_fkikMode:
					for num in xrange(len(otherFkAnims)):
						thisAnim = fkAnims[num]
						if not thisAnim.rotateX.isLocked():
							thisAnim.rotateX.set(otherFkRots[num][0])
						if not thisAnim.rotateY.isLocked():
							thisAnim.rotateY.set(otherFkRots[num][1])
						if not thisAnim.rotateZ.isLocked():
							thisAnim.rotateZ.set(otherFkRots[num][2])
				else:
					try:
						pvAnim.translate.set(-otherPvTrans)
					except: pass
					try:
						ikAnim.translate.set(-otherIkTrans)
					except: pass
					try:
						ikAnim.rotate.set(otherIkRot)
					except: pass
				if not fkikMode == other_fkikMode:
					self.alignSwitch()
			return [self]

class FKIKLeg(RigComponent):
	def __init__(self, heelJoint, toeJoint, insideJoint, outsideJoint,  side, bodyPart, startJoint, endJoint,stretchy = 0, node=''):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'FKIKLeg'):
					self.networkNode = node
				else:
					printError("FKIKLeg: node %s is not a FKIKLeg metaNode"%(node))
			else:
				printError("FKIKLeg: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'FKIKLeg', 1.0, 'leg chain that can switch between Fk and IK', side, bodyPart, startJoint, endJoint)
			compName = '%s_%s'%(side, bodyPart)
			chain = chainBetween(startJoint, endJoint)
			bind_joints = []
			for item in chain:
				item  = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
					
			#error checking
			heelJoint = PyNode(heelJoint)
			insideJoint = PyNode(insideJoint)
			outsideJoint = PyNode(outsideJoint)
			toeJoint = PyNode(toeJoint)
			
			#num in joint chain need 5
					
			#create ik, fk, control joints
			FK_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', "FK")
			control_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'control')
			IK_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', "IK")
			
			#create pivot joints, use the foot joint to base rotation
			heel_piv = duplicate(bind_joints[3], po =1, n= '%s_heel_piv_joint'%compName)[0]
			toe_piv = duplicate(bind_joints[3], po =1, n= '%s_toe_piv_joint'%compName)[0]
			toe_lift_piv = duplicate(bind_joints[3], po =1, n= '%s_toe_lift_piv_joint'%compName)[0]
			toe_fk_piv = duplicate(bind_joints[3], po =1, n= '%s_toe_fk_piv_joint'%compName)[0]# will take rotate info from FK when align switching
			inside_piv = duplicate(bind_joints[3], po =1, n= '%s_inside_piv_joint'%compName)[0]
			outside_piv = duplicate(bind_joints[3], po =1, n= '%s_outside_piv_joint'%compName)[0]
			parent([heel_piv, toe_piv, toe_lift_piv, toe_fk_piv, inside_piv, outside_piv], w=1)
			alignPointOrient(heelJoint, heel_piv, 1,0)
			alignPointOrient(insideJoint, inside_piv, 1,0)
			alignPointOrient(outsideJoint, outside_piv, 1,0)
			alignPointOrient(toeJoint, toe_piv, 1,0)
			alignPointOrient(bind_joints[3], toe_lift_piv, 1,0)
			alignPointOrient(bind_joints[3], toe_fk_piv, 1,0)
			delete(heelJoint, toeJoint, insideJoint, outsideJoint)
			
			#Rename
			for x in xrange(len(FK_joints)):
				FK_joints[x].rename("%s_%i_fk_joint"%(compName, x+1))
				IK_joints[x].rename("%s_%i_ik_joint"%(compName, x+1))
				control_joints[x].rename("%s_%i_control_joint"%(compName, x+1))
			
			#connect FK joints
			for obj in FK_joints[:-1]:
				addBoxToJoint(obj)
				lockAndHideAttrs(obj, ['tx', 'ty', 'tz', 'sx', 'sy', 'sz', 'radius'])
				obj.tx.set(keyable = 0)
				obj.v.set(keyable = 0)
				addAnimAttr(obj)
				obj.rename(obj.name().replace('joint', 'anim'))
			lockAndHideAttrs(FK_joints[1], ["ry", "rx"]) #knee
			lockAndHideAttrs(FK_joints[3], ["ry", "rx"]) #toe/ball
			
			#IKHandle
			buf = ikHandle(startJoint = IK_joints[0], endEffector = IK_joints[2], sol = 'ikRPsolver', w=1)
			ik = buf[0]
			ik.rename('%s_ik'%compName)
			eff = buf[1]
			eff.rename('%s_eff'%compName)
			
			#create single chain Ik's for foot
			foot_ik = ikHandle( sj= IK_joints[2], ee = IK_joints[3], sol ='ikSCsolver')[0]
			toe_ik = ikHandle( sj= IK_joints[3], ee = IK_joints[4], sol ='ikSCsolver')[0]
			
			#Ik anim
			select(cl=1)
			animJoint = joint()
			labels = getJointLabels(IK_joints[2])
			animJoint.rename("%s_%s_ik_anim"%(labels[0], labels[1]))
			addAnimAttr(animJoint)
			
			cube = polyCube()[0]
			appendShape(cube, animJoint)
			delete(cube)
			
			alignPointOrient(IK_joints[2], animJoint, 1,1)
			animJointGrp = createZeroedOutGrp(animJoint)
			animJoint.v.set(keyable = 0)
			
			#add and connect attrs to the IK anim
			animJoint.addAttr('heelSpin', keyable=1,dv =0, min = -180, max = 180, dv = 0)
			animJoint.addAttr('heelLift', keyable =1, dv=0,min = -180, max = 180, dv = 0)
			animJoint.addAttr('toeSpin',  keyable=1, dv = 0, min = -180, max = 180, dv = 0)
			animJoint.addAttr('ballLift',  keyable=1, dv = 0, min = -180, max = 180, dv = 0)
			animJoint.addAttr('toeLift',  keyable=1, dv = 0, min = -180, max = 180, dv = 0)
			animJoint.addAttr('toeWiggle', keyable=1, dv = 0, min = -180, max = 180, dv = 0)
			animJoint.addAttr('sideToSide', keyable=1, dv = 0, min = -90, max = 90, dv = 0)
				#heelspin
			animJoint.heelSpin.set(-180)
			heel_piv.rotateY.set(-180)
			setDrivenKeyframe(heel_piv.rotateY, cd = animJoint.heelSpin, itt='linear', ott = 'linear')
			animJoint.heelSpin.set(180)
			heel_piv.rotateY.set(180)
			setDrivenKeyframe(heel_piv.rotateY, cd = animJoint.heelSpin, itt='linear', ott = 'linear')
				#heelLift
			animJoint.heelLift.set(-180)
			heel_piv.rotateZ.set(-180)
			setDrivenKeyframe(heel_piv.rotateZ, cd = animJoint.heelLift, itt='linear', ott = 'linear')
			animJoint.heelLift.set(180)
			heel_piv.rotateZ.set(180)
			setDrivenKeyframe(heel_piv.rotateZ, cd = animJoint.heelLift, itt='linear', ott = 'linear')
				#toeSpin
			animJoint.toeSpin.set(180)
			toe_piv.rotateY.set(-180)
			setDrivenKeyframe(toe_piv.rotateY, cd = animJoint.toeSpin, itt='linear', ott = 'linear')
			animJoint.toeSpin .set(-180)
			toe_piv.rotateY.set(180)
			setDrivenKeyframe(toe_piv.rotateY, cd = animJoint.toeSpin, itt='linear', ott = 'linear')
				#ballLift
			animJoint.ballLift.set(180)
			toe_lift_piv.rotateZ.set(-180)
			setDrivenKeyframe(toe_lift_piv.rotateZ, cd = animJoint.ballLift, itt='linear', ott = 'linear')
			animJoint.ballLift .set(-180)
			toe_lift_piv.rotateZ.set(180)
			setDrivenKeyframe(toe_lift_piv.rotateZ, cd = animJoint.ballLift, itt='linear', ott = 'linear')
				#toeLift
			animJoint.toeLift.set(180)
			toe_piv.rotateZ.set(-180)
			setDrivenKeyframe(toe_piv.rotateZ, cd = animJoint.toeLift, itt='linear', ott = 'linear')
			animJoint.toeLift .set(-180)
			toe_piv.rotateZ.set(180)
			setDrivenKeyframe(toe_piv.rotateZ, cd = animJoint.toeLift, itt='linear', ott = 'linear')
				#toeWiggle
			animJoint.toeWiggle.set(180)
			toe_fk_piv.rotateZ.set(180)
			setDrivenKeyframe(toe_fk_piv.rotateZ, cd = animJoint.toeWiggle, itt='linear', ott = 'linear')
			animJoint.toeWiggle .set(-180)
			toe_fk_piv.rotateZ.set(-180)
			setDrivenKeyframe(toe_fk_piv.rotateZ, cd = animJoint.toeWiggle, itt='linear', ott = 'linear')
				#sideToSide
			animJoint.sideToSide.set(0)
			inside_piv.rotateX.set(0)
			outside_piv.rotateX.set(0)
			setDrivenKeyframe(inside_piv.rotateX, cd = animJoint.sideToSide, itt='linear', ott = 'linear')
			setDrivenKeyframe(outside_piv.rotateX, cd = animJoint.sideToSide, itt='linear', ott = 'linear')	
			animJoint.sideToSide.set(90)
			outside_piv.rotateX.set(-90)
			setDrivenKeyframe(outside_piv.rotateX, cd = animJoint.sideToSide, itt='linear', ott = 'linear')
			animJoint.sideToSide.set(-90)
			inside_piv.rotateX.set(90)
			setDrivenKeyframe(inside_piv.rotateX, cd = animJoint.sideToSide, itt='linear', ott = 'linear')
				#reset animJoint
			resetAttrs(animJoint)
			
			#IK foot parenting
			'''
			anim
				heel via parent constraint
					outside
						inside
							toe
								toe fk
									toe ik
								toe lift
									foot ik
									leg ik
			'''
			parent(foot_ik, ik, toe_lift_piv)
			parent(toe_ik, toe_fk_piv)
			parent(toe_fk_piv, toe_lift_piv, toe_piv)
			parent(toe_piv, inside_piv)
			parent(inside_piv, outside_piv)
			parent(outside_piv, heel_piv)
			heel_piv_grp = group(heel_piv, n = (heel_piv.name() + "_grp"))
			parentConstraint(animJoint, heel_piv_grp, mo =1, w=1)
			
			#PV
			pvLoc = createPVLocator(FK_joints[0], FK_joints[1], FK_joints[2])
			labels = getJointLabels(IK_joints[1])
			select(cl=1)
			pvJoint = joint()
			pvJoint.rename("%s_%s_pv_anim"%(labels[0], labels[1]))
			sphere = polySphere()[0]
			appendShape(sphere, pvJoint)
			alignPointOrient(pvLoc, pvJoint, 1,0)
			alignPointOrient(IK_joints[1], pvJoint, 0,1)
			addAnimAttr(pvJoint)
			delete(pvLoc)
			delete(sphere)
			poleVectorConstraint(pvJoint, ik, w=1)
			pvJointGrp = createZeroedOutGrp(pvJoint)
			pvJoint.v.set(keyable = 0)
			
			#connect IK and FK to the control
			select(cl=1)
			switchGroup = group(n = '%s_FKIK_switch'%compName)
			switchGroup.addAttr('FKIK_switch', keyable = 1)
			switchGroup.FKIK_switch.setMax(1)
			switchGroup.FKIK_switch.setMin(0)
			switchGroup.FKIK_switch.setKeyable(1)
			rev = createNode('reverse')
			switchGroup.FKIK_switch >> rev.inputX
			for inc in xrange(len(FK_joints)):
				const = parentConstraint(FK_joints[inc], IK_joints[inc], control_joints[inc])	
				rev.outputX >> const.w0
				switchGroup.FKIK_switch >> const.w1
			lockAndHideAttrs(switchGroup, ('tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'sx', 'sy','sz','v'))
			
			#ik stretchyness
			startPoint = None
			endPoint = None
			zeroGrp = None
			globalMultiplier = createNode('multiplyDivide')
			distDim = None
			if stretchy:
				#get total distance
				totalLength = 0
				totalLength += IK_joints[1].translateX.get() #upper arm length
				totalLength += IK_joints[2].translateX.get() #lower arm length
				totalLength = abs(totalLength)
				#create way of keeping currnet distance
				startPoint = spaceLocator()
				startPoint.translate.set(3.3615,2.2215554,7.659)#random point
				endPoint = spaceLocator()
				endPoint.translate.set(2.84596,23.2155,0.3325)#random point
				distDim = distanceDimension(sp=startPoint.translate.get(),ep= endPoint.translate.get())
				distDim = PyNode(distDim)
				alignPointOrient(IK_joints[0], startPoint, 1,0)
				alignPointOrient(IK_joints[2], endPoint, 1,0)
				#move end with foot attrs
				heelRotGrp = group(empty = 1, n = "%s_heel_rot"%compName)
				alignPointOrient(heel_piv, heelRotGrp, 1,1)
				heelRotGrp.rotateOrder.set(heel_piv.rotateOrder.get())
				
				ballRotGrp = group(empty = 1, n = "%s_ball_rot"%compName)
				alignPointOrient(IK_joints[3], ballRotGrp, 1,1)
				ballRotGrp.rotateOrder.set(IK_joints[3].rotateOrder.get())
				
				toeRotGrp = group(empty = 1, n = "%s_toe_rot"%compName)
				alignPointOrient(toe_piv, toeRotGrp,1,1)
				toeRotGrp.rotateOrder.set(toe_piv.rotateOrder.get())
				
				insideRotGrp = group(empty =1, n = "%s_inside_rot"%compName)
				alignPointOrient(inside_piv, insideRotGrp, 1,1)
				insideRotGrp.rotateOrder.set(inside_piv.rotateOrder.get())
				
				outsideRotGrp = group(empty = 1, n = "%s_outside_rot"%compName)
				alignPointOrient(outside_piv, outsideRotGrp, 1,1)
				outsideRotGrp.rotateOrder.set(outside_piv.rotateOrder.get())
				
				heelZeroGrp = createZeroedOutGrp(heelRotGrp)
				ballZeroGrp = createZeroedOutGrp(ballRotGrp)
				toeZeroGrp = createZeroedOutGrp(toeRotGrp)
				insideZeroGrp = createZeroedOutGrp(insideRotGrp)
				outsideZeroGrp = createZeroedOutGrp(outsideRotGrp)
				
				parent(outsideZeroGrp,heelRotGrp)
				parent(insideZeroGrp, outsideRotGrp)
				parent(toeZeroGrp, insideRotGrp)
				parent(ballZeroGrp, toeRotGrp)
				parent(endPoint, ballRotGrp)
				
				
				animJoint.heelSpin >> heelRotGrp.rotateY
				animJoint.heelLift >> heelRotGrp.rotateZ
				
				ballRotMult = createNode("multiplyDivide")
				ballRotMult.input2X.set(-1)
				animJoint.ballLift >> ballRotMult.input1X
				ballRotMult.outputX >> ballRotGrp.rotateZ
				
				toeRotMult = createNode("multiplyDivide")
				toeRotMult.input2X.set(-1)
				toeRotMult.input2Y.set(-1)
				animJoint.toeLift >> toeRotMult.input1X
				toeRotMult.outputX >> toeRotGrp.rotateZ
				animJoint.toeSpin >> toeRotMult.input1Y
				toeRotMult.outputY >> toeRotGrp.rotateY
				
				insideRotMult = createNode("multiplyDivide")
				insideRotMult.input2X.set(-1)
				transformLimits(insideRotGrp, erx=(True, False), rx=(0, 0))
				animJoint.sideToSide >> insideRotMult.input1X
				insideRotMult.outputX >> insideRotGrp.rotateX
				
				outsideRotMult = createNode("multiplyDivide")
				outsideRotMult.input2X.set(-1)
				transformLimits(outsideRotGrp, erx=(False, True), rx=(0, 0))
				animJoint.sideToSide >> outsideRotMult.input1X
				outsideRotMult.outputX >> outsideRotGrp.rotateX
				
				parentConstraint(animJoint, heelZeroGrp, mo=1, w=1)
				zeroGrp = heelZeroGrp
				#create basic setup with calc nodes
					#multipler
				
				
				globalMultiplier.input1X.set(totalLength)
				globalMultiplier.input2X.set(1)
				#still have to put topCon globalsclae input globalMultiplier.input2X
				
				ratio = createNode('multiplyDivide') #outputX = currentLength\(orig*globalScale)
				ratio.operation.set(2)#divide
				globalMultiplier.outputX >> ratio.input2X
				distDim.distance >> ratio.input1X
					#conditional
				condition = createNode('condition')
				ratio.outputX >> condition.firstTerm
				condition.secondTerm.set(1)
				condition.operation.set(2)#greater than, if current ratio > 1
				condition.colorIfFalseR.set(1)
				ratio.outputX >> condition.colorIfTrueR
				
				#add stretchy to the FK and IK joints
				for j in xrange(2):
					ikJoint = IK_joints[j+1] # want to use FK/IK_joints[1,2] 
					jointMult = createNode('multiplyDivide')
					orig = ikJoint.translateX.get()
					jointMult.input1X.set(orig)
					condition.outColorR >> jointMult.input2X
					jointMult.outputX >> ikJoint.translateX
			
			#connect control joints to bind joints
			for inc in xrange(len(FK_joints)):#-1
				parentConstraint(control_joints[inc], bind_joints[inc])
			
			lockAndHideAttrs(animJoint, ['sx','sy','sz','radius'])
			lockAndHideAttrs(pvJoint, ['rx', 'ry', 'rz','sx','sy','sz','radius'])	
				
			#grouping
			select(cl=1)
			jointGrp = group([FK_joints[0], IK_joints[0], control_joints[0]],n='%s_joint_grp'%compName)
			animGrp = group([animJointGrp, pvJointGrp], n = "%s_anim_grp"%compName)
			dntGrp = group([distDim, switchGroup, heel_piv_grp], n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
			
			#hiding
			if stretchy:
				parent(startPoint, dntGrp)
				parent(zeroGrp, dntGrp)
			control_joints[0].hide()
			dntGrp.hide()
			heel_piv.v.set(0)
			switchGroup.FKIK_switch >> IK_joints[0].visibility
			rev.outputX >> FK_joints[0].visibility
			switchGroup.FKIK_switch >> pvJoint.v
			switchGroup.FKIK_switch >> animJoint.v
			animJointGrp.inheritsTransform.set(0)#allows the feet not to move when hip moves, if hip.
			
			
			#connections to meta
			connectToMeta(ik, self.networkNode, 'ikHandle')
			connectToMeta(pvJoint, self.networkNode, 'pvAnim')
			connectToMeta(animJoint, self.networkNode, 'ikAnim')
			connectToMeta(switchGroup, self.networkNode, 'switchGroup')		
			self.networkNode.setAttr('switchAttr', 'FKIK_switch',  f=1)
			self.networkNode.setAttr('stretchy', stretchy,  f=1)
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			connectToMeta(dntGrp, self.networkNode, 'dntGrp')
			connectToMeta(heel_piv, self.networkNode, 'heelPiv')
			connectToMeta(toe_piv, self.networkNode, 'toePiv')
			connectToMeta(inside_piv, self.networkNode, 'insidePiv')
			connectToMeta(outside_piv, self.networkNode, 'outsidePiv')
			connectToMeta(toe_lift_piv, self.networkNode, 'toeLiftPiv')
			connectToMeta(toe_fk_piv, self.networkNode, 'toeFKPiv')
			connectToMeta(globalMultiplier, self.networkNode, 'globalMultiplier')
			connectChainToMeta(FK_joints, self.networkNode, 'FKJoints')
			connectChainToMeta(IK_joints, self.networkNode, 'IKJoints')
			connectChainToMeta(control_joints, self.networkNode, 'controlJoints')
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
	
	def getSwitchAttr(self):
		switchNode = self.networkNode.switchGroup.listConnections()[0]
		switchAttrName = self.networkNode.switchAttr.get()
		return switchNode.attr(switchAttrName)
	
	def alignSwitch(self):
		'''
		toggle between FK and IK while keeping current joint placement
		'''
		switchGroup = listConnections(self.networkNode.switchGroup)[0]	
		switchAttr = self.networkNode.switchAttr.get()
		
		if switchGroup.attr(switchAttr).get() < .5:
			#snap ik to fk
			ikjs = self.networkNode.IKJoints.listConnections()
			fkjs = self.networkNode.FKJoints.listConnections()
			controljs = self.networkNode.controlJoints.listConnections()
			ikAnim = listConnections(self.networkNode.ikAnim)[0]
			pvAnim = listConnections(self.networkNode.pvAnim)[0]
			ikAnim.translate.lock()
			resetAttrs(ikAnim)
			ikAnim.translate.unlock()
			alignPointOrient(controljs[2],ikAnim, 1,1)
			pvLoc = createPVLocator(fkjs[0], fkjs[1], fkjs[2])
			alignPointOrient(pvLoc, pvAnim, 1,0)
			alignPointOrient(ikjs[1], pvAnim, 0,1)
			delete(pvLoc)
			ball_fk_joint = fkjs[-2]
			ikAnim.toeWiggle.set(ball_fk_joint.rotateZ.get())
			switchGroup.attr(switchAttr).set(1)
			setKeyframe(switchGroup.attr(switchAttr), itt='spline' , ott = 'step')
			 
		else:
			#snap fk to ik
			ikjs = self.networkNode.IKJoints.listConnections()
			fkjs = self.networkNode.FKJoints.listConnections()
			for inc in xrange(len(fkjs)):
				if inc == 1 or inc == 2:
					fkjs[inc].translateX.unlock()
					fkjs[inc].translateX.set(ikjs[inc].translateX.get())
					fkjs[inc].translateX.lock()
				alignPointOrient(ikjs[inc],fkjs[inc], 0,1)
			switchGroup.attr(switchAttr).set(0)
			setKeyframe(switchGroup.attr(switchAttr), itt='spline' , ott = 'step')	
	
			
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
			
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.controlJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.controlJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("FKIKChain.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			control_joints = self.networkNode.controlJoints.listConnections()
			fk_joints = self.networkNode.FKJoints.listConnections()
			ik_joints = self.networkNode.IKJoints.listConnections()
			for inc in xrange(len(bind_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return control_joints[inc]
				if location == control_joints[inc]:
					return control_joints[inc]
				if location == fk_joints[inc]:
					return control_joints[inc]
				if location == ik_joints[inc]:
					return control_joints[inc]
		raise Exception("FKIKChain.getConnectObj: location wasn't found, try 'start', 'end', or name of bind ,fk, ik, or control joint ")

	def isIK(self):
		return True
	
	def getIK(self):
		return self.networkNode.ikHandle.listConnections()[0]
		
	def isFK(self):
		return True

	def getIKAnim(self):
		'''
		returns the ik anim at the end of the IK chain
		'''
		return self.networkNode.ikAnim.listConnections()[0]
		
	def getPVAnim(self):
		'''
		returns the pole vector anim
		'''	
		return self.networkNode.pvAnim.listConnections()[0]
		
	def getFKAnims(self):
		'''
		returns all the FK anims
		'''
		return self.networkNode.FKJoints.listConnections()[:-1]
	
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		allAnims = []
		allAnims.append(self.getPVAnim())
		allAnims.append(self.getIKAnim())
		map(lambda x: allAnims.append(x), self.getFKAnims())
		allAnims.append(self.networkNode.switchGroup.listConnections()[0])
		return allAnims
		
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''
		allAnims = []
		allAnims.append(self.getPVAnim())
		allAnims.append(self.getIKAnim())
		map(lambda x: allAnims.append(x), self.getFKAnims())
		for anim in allAnims:			
			resetAttrs(anim)	
		
	def parentUnder(self, obj):
		'''
		parent this rigComponent under the obj
		obj:
			object to parent under
		'''
		if not objExists(obj):
			raise Exception("RigComponent: can't parent under $s, obj doesn't exist"%obj)
		try:
			parent(self.networkNode.componentGrp.listConnections()[0], obj)
			root = getMetaRoot(obj, 'CharacterRig')
			if root:
				try:
					topCon = root.getTopCon()
					topCon.globalScale >> self.networkNode.globalMultiplier.listConnections()[0].input2X
					ikAnim = self.networkNode.ikAnim.listConnections()[0]
					zeroGrp = ikAnim.getParent()
					parentConstraint(topCon, zeroGrp, w=1, mo=1)
					scaleConstraint(topCon, zeroGrp, w=1, mo =1)
				except:
					pass
		except:
			raise Exception("%s.parentUnder: not implemeneted"%self.networkNode.metaType.get())
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		switchGroup = self.networkNode.switchGroup.listConnections()[0]
		switchAttr = self.networkNode.switchAttr.get()
		fkikMode = switchGroup.attr(switchAttr).get() < .5#true if fk
		
		pvAnim = self.getPVAnim()
		pvTrans = pvAnim.translate.get()
		ikAnim = self.getIKAnim()
		ikTrans = ikAnim.translate.get()
		ikRot = ikAnim.rotate.get()
		fkAnims = self.getFKAnims()
		fkRots = map(lambda x: x.rotate.get(), fkAnims)
		ikAnimAttrs = {"heelSpin": ikAnim.heelSpin.get(), "heelLift": ikAnim.heelLift.get(), "toeSpin": ikAnim.toeSpin.get(), "ballLift": ikAnim.ballLift.get(), "toeLift": ikAnim.toeLift.get(), "toeWiggle": ikAnim.toeWiggle.get(), "sideToSide": ikAnim.sideToSide.get() }
		if other == self:
			if fkikMode:
				map(lambda x: x.rotate.set(-x.rotate.get()[0],-x.rotate.get()[1],x.rotate.get()[2] ), fkAnims)
			else:	
				pvAnim.translate.set(pvTrans[0], pvTrans[1], -pvTrans[2])
				ikAnim.rotate.set(ikRot[0], ikRot[1], -ikRot[2])
				ikAnim.translate.set(ikTrans[0], ikTrans[1], -ikTrans[2])
				ikAnim.heelSpin.set(-ikAnim.heelSpin.get())
				ikAnim.toeSpin.set(-ikAnim.toeSpin.get())
				ikAnim.sideToSide.set(-ikAnim.sideToSide.get())
				return [self]
		else:
			otherPvAnim = other.getPVAnim()
			otherPvTrans = otherPvAnim.translate.get()
			otherIkAnim = other.getIKAnim()
			otherIkTrans = otherIkAnim.translate.get()
			otherIkRot = otherIkAnim.rotate.get()
			otherFkAnims = other.getFKAnims()
			otherFkRots = map(lambda x: x.rotate.get(), otherFkAnims)
			otherIkAnimAttrs = {"heelSpin": otherIkAnim.heelSpin.get(), "heelLift": otherIkAnim.heelLift.get(), "toeSpin": otherIkAnim.toeSpin.get(), "ballLift": otherIkAnim.ballLift.get(), "toeLift": otherIkAnim.toeLift.get(), "toeWiggle": otherIkAnim.toeWiggle.get(), "sideToSide": otherIkAnim.sideToSide.get() }
			otherSwitchGroup = other.networkNode.switchGroup.listConnections()[0]
			otherSwitchAttr = other.networkNode.switchAttr.get()
			other_fkikMode = otherSwitchGroup.attr(otherSwitchAttr).get() < .5#true if fk		
			if bothSides:
				if not fkikMode and not other_fkikMode: #both IK, do a nicer switch
					#change this
					ikAnim.translate.set(-otherIkTrans)
					ikAnim.rotate.set(otherIkRot)
					for x in ikAnimAttrs.keys():
						ikAnim.attr(x).set(otherIkAnimAttrs[x])
					pvAnim.translate.set(-otherPvTrans)
					#change other
					otherIkAnim.translate.set(-ikTrans)
					otherIkAnim.rotate.set(ikRot)
					for x in otherIkAnimAttrs.keys():
						otherIkAnim.attr(x).set(ikAnimAttrs[x])
					otherPvAnim.translate.set(-pvTrans)
					return [self, other]
				else:
					switched = 0
					if not (other_fkikMode == fkikMode):
						other.alignSwitch()
						switched = 1
						otherPvTrans = otherPvAnim.translate.get()
						otherIkTrans = otherIkAnim.translate.get()
						otherIkRot = otherIkAnim.rotate.get()
						otherFkAnims = other.getFKAnims()
						otherFkRots = map(lambda x: x.rotate.get(), otherFkAnims)
						otherIkAnimAttrs = {"heelSpin": otherIkAnim.heelSpin.get(), "heelLift": otherIkAnim.heelLift.get(), "toeSpin": otherIkAnim.toeSpin.get(), "ballLift": otherIkAnim.ballLift.get(), "toeLift": otherIkAnim.toeLift.get(), "toeWiggle": otherIkAnim.toeWiggle.get(), "sideToSide": otherIkAnim.sideToSide.get() }
					if fkikMode: #swap FKs
						#change this
						for num in xrange(len(otherFkAnims)):
							anim = fkAnims[num]
							if not anim.rotateX.isLocked():
								anim.rotateX.set(otherFkRots[num][0])
							if not anim.rotateY.isLocked():
								anim.rotateY.set(otherFkRots[num][1])
							if not anim.rotateZ.isLocked():
								anim.rotateZ.set(otherFkRots[num][2])
						#change other
						for num in xrange(len(fkAnims)):
							otherAnim = otherFkAnims[num]
							if not otherAnim.rotateX.isLocked():
								otherAnim.rotateX.set(fkRots[num][0])
							if not otherAnim.rotateY.isLocked():
								otherAnim.rotateY.set(fkRots[num][1])
							if not otherAnim.rotateZ.isLocked():
								otherAnim.rotateZ.set(fkRots[num][2])
					else: #swap IKs
						#change this
						ikAnim.translate.set(-otherIkTrans)
						ikAnim.rotate.set(otherIkRot)
						for x in ikAnimAttrs.keys():
							ikAnim.attr(x).set(otherIkAnimAttrs[x])
						pvAnim.translate.set(-otherPvTrans)
						#change other
						otherIkAnim.translate.set(-ikTrans)
						otherIkAnim.rotate.set(ikRot)
						for x in otherIkAnimAttrs.keys():
							otherIkAnim.attr(x).set(ikAnimAttrs[x])
						otherPvAnim.translate.set(-pvTrans)
					if switched:
						other.alignSwitch()
					return [self, other]				
			else:
				#mirror self
				if not fkikMode == other_fkikMode:
					self.alignSwitch()
				if other_fkikMode:
					for num in xrange(len(otherFkAnims)):
							anim = fkAnims[num]
							if not anim.rotateX.isLocked():
								anim.rotateX.set(otherFkRots[num][0])
							if not anim.rotateY.isLocked():
								anim.rotateY.set(otherFkRots[num][1])
							if not anim.rotateZ.isLocked():
								anim.rotateZ.set(otherFkRots[num][2])
				else:
					try:
						pvAnim.translate.set(-otherPvTrans)
					except: pass
					try:
						ikAnim.translate.set(-otherIkTrans)
					except: pass
					try:
						ikAnim.rotate.set(otherIkRot)
					except: pass
					try:
						for x in ikAnimAttrs.keys():
							ikAnim.attr(x).set(otherIkAnimAttrs[x])
					except: pass
				if not fkikMode == other_fkikMode:
					self.alignSwitch()
			return [self]
	
class FaceRig(RigComponent):
	def __init__(self, faceGeo, node = ''):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'FaceRig'):
					self.networkNode = node
				else:
					printError("FaceRig: node %s is not a FaceRig metaNode"%(node))
			else:
				printError("FaceRig: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'FaceRig', 1.0, 'rig that contains many NurbsFaceComponent','center', 'face')
			connectToMeta(faceGeo, self.networkNode, 'faceGeo')
			self.networkNode.addAttr('faceComponents',dt = 'string', multi = 1)
		
	def addFaceComponent(self, faceComponent):	
		if not isinstance(faceComponent, NurbsFaceComponent):
			printError('addFaceComponent: %s is not a faceComponent'%faceComponent)
			
		num = self.networkNode.faceComponents.evaluateNumElements()
		connectToMeta(faceComponent.networkNode, self.networkNode, 'faceComponents')
		
	def getFaceComponents(self):
		return listConnections(self.networkNode.faceComponents)
	
	def createFaceComponent(self, locators):
		if not (type(locators) is list or type(locators) is tuple):
			locators = [locators]
		for locator in locators:	
			comp = NurbsFaceComponent(locator, listConnections(self.networkNode.faceGeo)[0])
			self.addFaceComponent(comp)

class SDKComponent(RigComponent):
	def __init__(self, obj, side, bodyPart, copyLimits = 0, node = None):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		obj:
			the object that has the location of the SDKAttr, inherits transform limits
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'SDKComponent'):
					self.networkNode = node
				else:
					printError("SDKComponent: node %s is not a SDKComponent metaNode"%(node))
			else:
				printError("SDKComponent: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'SDKComponent', 1.0, 'allows for SDKs on the rig', side, bodyPart, '', obj)
			
			
			#create SDK Anim
			compName = "%s_%s"%(side, bodyPart)
			obj = PyNode(obj)
			sdk_anim = None
			
			#createGrps
			select(cl=1)
			animGrp = group(empty = 1, n = "%s_anim_grp"%compName)
			mainGrp = group(animGrp,n = "%s_component_group"%compName)
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			alignPointOrient(obj, mainGrp, 1,1)
			
			# copy limits
			objLimits = {}
			if copyLimits:
				limits = ["translateMinX", "translateMaxX","translateMinY", "translateMaxY","translateMinZ", "translateMaxZ",
							"rotateMinX", "rotateMaxX","rotateMinY", "rotateMaxY","rotateMinZ", "rotateMaxZ",
							"scaleMinX", "scaleMaxX","scaleMinY", "scaleMaxY","scaleMinZ", "scaleMaxZ"]
				for limit in limits:
					lim = obj.getLimit(limit)
					enable = obj.isLimited(limit)
					objLimits[limit] = [enable, lim]
				
			
			#create Anim
			if hasAnimAttr(obj):
				sdk_anim = obj
			if not sdk_anim:
				sdk_anim = joint(n = "%s_sdk_anim"%compName)
				cube = polyCube()[0]
				alignPointOrient(sdk_anim, cube, 1,1)
				swapShape(sdk_anim, cube)
				lockAndHideAttrs(sdk_anim, ['radius'])
				addAnimAttr(sdk_anim)
				alignPointOrient(obj, sdk_anim, 1, 1)
				delete(obj)
				parent(sdk_anim, animGrp)
				createZeroedOutGrp(sdk_anim)
			
			#paste limits
			if copyLimits:
				for key, value in objLimits.items():
					sdk_anim.setLimited(key, value[0])
					sdk_anim.setLimit(key, value[1])
			
			#connect to meta
			connectToMeta(animGrp, self.networkNode, 'animGrp')
			connectToMeta(sdk_anim, self.networkNode, 'SDKAnim')
			self.networkNode.addAttr('SDK', dt = 'string', m=1)
	
	def addSDK(self, folder, endPose, sdk_attr, startPose = 'neutral', startValue = 0, endValue = 1, multiply = 0):
		anim = self.networkNode.SDKAnim.listConnections()[0]
		if not anim.hasAttr(sdk_attr):
			anim.addAttr(sdk_attr, at= 'float', k=1,min = startValue, max = endValue, dv = startValue)
		sdkNode = SDK(folder, endPose, anim.name() + "." + sdk_attr, startPose = startPose, startValue = startValue, endValue = endValue, multiply = multiply)
		connectToMeta(sdkNode.networkNode, self.networkNode, 'SDK')
			
	def mirror(self, bothSides = 0):
		pass
	
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
		
		
	def getConnectObj(self, location):
		return self.networkNode.SDKAnim.listConnections()[0]
	
	def getAllAnims(self):
		return [self.networkNode.SDKAnim.listConnections()[0]]
		
	def toDefaultPose(self):
		metaSDKs = self.networkNode.SDK.listConnections()
		metaSDKs = map(lambda x: fromNetworkToObject(x), metaSDKs)
		for sdk in metaSDKs:
			sdk.toDefaultPose()
		#part added for nebbish production, reset the objects actual attributes
		resetAttrs(self.networkNode.SDKAnim.listConnections()[0])
		
		
	
class SDK(MetaNode):
	def __init__(self, sdkFolder, endPose, sdk_attr, startPose = 'neutral', startValue = 0, endValue = 1,multiply = 0, node = None):
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'SDK'):
					self.networkNode = node
				else:
					printError("SDK: node %s is not a SDK metaNode"%(node))
			else:
				printError("SDK: node %s doesn't exist"%(node))
		else:
			MetaNode.__init__( self, "SDK", 1.0, 'stores information about a set driven key')
			self.networkNode.addAttr('SDKGrps', dt = 'string', m=1)
			self.networkNode.addAttr('SDKAdds', dt = 'string', m=1)
			
			sdk_attr = PyNode(sdk_attr)
			node = PyNode(sdk_attr.node())
			sdkAttrName = sdk_attr.name().replace(node.name() + ".", "",1)

			# Check range and extend if needed
			[currentStart,currentEnd] = sdk_attr.getRange()
			if startValue < endValue :
				if startValue < currentStart :
					currentStart = startValue
				if endValue > currentEnd:
					currentEnd = endValue
			else : 
				if endValue < currentStart :
					currentStart = endValue
				if startValue > currentEnd:
					currentEnd = startValue
			try:
				sdk_attr.setRange(currentStart, currentEnd)
				sdk_attr.set(keyable=1)
			except:
				sdk_attr.set(keyable=1)
				
			
			#read in poses
			startPoseFile = sdkFolder + "/" + startPose + ".xml"
			endPoseFile = sdkFolder + "/" + endPose + ".xml"
			
			pose1 = Pose().readXML(startPoseFile)
			pose2 = Pose().readXML(endPoseFile)
			
			p1Attrs = pose1.getAttributes()
			p2Attrs = pose2.getAttributes()
			
			#make dictionary attribute start and end Values {attr: [startValue, endValue]}
			attrStartEnd = {}
			for attr in p2Attrs:
				if attr in p1Attrs:
					animStartValue = pose1.getValue(attr)
					animEndValue =  pose2.getValue(attr)
					#if animStartValue != animEndValue:
					attrStartEnd[attr] = [animStartValue, animEndValue]
			
			#make dictionary for amin attriutes {anim, [attr1, attr2, ...]} 
			animAttrs = {}
			for attr in attrStartEnd.keys():
				anim = attr.split(".")[0]
				if objExists(anim):
					if anim in animAttrs.keys():
						list = animAttrs[anim]
						list.append(attr)
						animAttrs[anim] = list
					else:
						animAttrs[anim] = [attr]
			
			for anim, attrs in animAttrs.items():
				anim = PyNode(anim)
				transformAttrs = []
				otherAttrs = []
				#organize by transform and other attributes
				for attr in attrs:
					attr = PyNode(attr)
					transattrs = ['translateX', 'translateY', 'translateZ', 'rotateX', 'rotateY', 'rotateZ', 'scaleX', 'scaleY', 'scaleZ']
					if attr.name().split(anim.name() + ".")[-1] in transattrs:
						transformAttrs.append(attr)
					else:
						otherAttrs.append(attr)
				
				if transformAttrs:
					#create sdk grp 
					
					sdk_grp = None
					if objExists(anim.name() + "_%s_sdk_grp"%sdkAttrName):
						sdk_grp = PyNode(anim.name() + "_%s_sdk_grp"%sdkAttrName)
					#create sdk grp
					else:
						sdk_grp = group(empty = 1, n = anim.name() + "_%s_sdk_grp"%sdkAttrName)
						alignPointOrient(anim, sdk_grp, 1, 1)
						par = anim.getParent()
						parent(sdk_grp, par)
						parent(anim, sdk_grp)
						if not par.name().endswith("_sdk_grp"):
							zgrp = createZeroedOutGrp(sdk_grp)
					
						#if sdk_grp.rotateOrder.get() != anim.rotateOrder.get():
						#  print 'Matching sdk rotation for '+anim+' anim order '+str(anim.rotateOrder.get())+' sdk order '+str(sdk_grp.rotateOrder.get())
						#Make sure to match the rotate order or saved poses won't work
						sdk_grp.rotateOrder.set( anim.rotateOrder.get())
					
					# Unlock any translation attributes and remember
					wasLocked = {}
					for attrib in ['translate','tx','ty','tz']:
						if anim.attr(attrib).isLocked():
							wasLocked[attrib] = True
							anim.attr(attrib).unlock()
						else:
							wasLocked[attrib] = False
					
					# Set anim translation to zero so it isn't double
					# translated now that the zgrp is a parent of it
					anim.translate.set([0,0,0])
					
					# Re-lock the translation attributes
					for attrib in ['translate','tx','ty','tz']:
						if wasLocked[attrib]:
							anim.attr(attrib).lock()

					#create sdk
					for attr in transformAttrs:
						#getValues
						attrName = attr.name().replace(attr.node().name() + ".", "")
						sdk_grp_attr = sdk_grp.attr(attrName)
						currentValue = attr.get()
						animStartValue = attrStartEnd[attr.name()][0]
						animEndValue = attrStartEnd[attr.name()][1]
						
						
						hasMultiply = None
						con = sdk_grp_attr.listConnections(s=1, d=0,scn=1)
						if con: #if a connection already exists add another key into orig SDK animCurve
							
							hasMultiply = con[0].type() == 'multiplyDivide'
							animCurv = con[0]
							if hasMultiply:
								animCurv = con[0].input1X.listConnections(s=1, d=0,scn=1)[0]
							setKeyframe(animCurv, f=startValue, v = animStartValue, itt='linear', ott='linear')
							setKeyframe(animCurv, f=endValue, v = animEndValue, itt='linear', ott='linear')
							connectAttr(sdk_attr, animCurv.input, f=1)
							
							
						else:#if no connection create a new one
							#startSDK
							sdk_attr.set(startValue)
							sdk_grp_attr.set(animStartValue)
							setDrivenKeyframe(sdk_grp_attr, cd=sdk_attr, itt = 'linear', ott = 'linear', dv = startValue,v=animStartValue, ib=0)
							
							#end SDK
							sdk_attr.set(endValue)
							sdk_grp_attr.set(animEndValue)
							setDrivenKeyframe( sdk_grp_attr, cd=sdk_attr, itt = 'linear', ott= 'linear', dv = endValue,v=animEndValue, ib=0)
							
							# Set the attribute back to the default value, if it doesn't
							# have one, assume 0
							value = addAttr(sdk_attr,q=1, dv=1)
							if value == None:
								value = 0
							sdk_attr.set(value)
							#sdk_attr.set(addAttr(sdk_attr,q=1, dv=1))
							#attr.set(currentValue)
							
						#connectToMeta
						connectToMeta(sdk_grp, self.networkNode, 'SDKGrps')
							
						if multiply: #add Multiply Node 
							if not hasMultiply: #add Multiply node if one doesn't already exists
								animationCurve = sdk_grp_attr.listConnections(s=1, d=0,scn=1)[0]
								
								#create amplitude attribute
								multAttrName = sdk_attr.name().split(".")[-1] + "_multiply"
								if not objExists(sdk_attr.node().name() + "."+multAttrName):
									sdk_attr.node().addAttr(multAttrName, keyable = 1, dv = 1)
								mult_attr = sdk_attr.node().attr(multAttrName)
								
								#create multiplyDivideNode
								multiNode = createNode('multiplyDivide', n = sdk_grp_attr.name().replace(".", "_") + "amplitude")
								
								#connect amplitude Node
								connectAttr(animationCurve.output, multiNode.input1X, f=1)
								connectAttr(mult_attr, multiNode.input2X, f=1)
								connectAttr(multiNode.outputX, sdk_grp_attr, f=1)
							else: #connect To existing node
								multiNode = sdk_grp_attr.listConnections(s=1, d=0,scn=1)[0]
								connectAttr(multiNode.outputX, sdk_grp_attr, f=1)
									
				if otherAttrs:
					for attr in otherAttrs:
						'''
						from:
						animation ---> node.attr ---> otherNode


						to:
										metaAnimation--->|addNode|-->  node.meta_attr_attr ----> otherNode
						animation --->  node.attr -----/
						'''

						attr = PyNode(attr)
						node = attr.node()

						#create new attr
						attrName = attr.name().replace(node.name() + ".", "")
						newAttrName = "meta_attr_" + attrName
						node.addAttr(newAttrName, keyable = 0)
						newAttr= node.attr(newAttrName)

						#change the output connections
						outputConnections = attr.outputs(p=1)
						for out_con in outputConnections:
							newAttr >> out_con

						#create add node for multiple input connections
						addNode = createNode('plusMinusAverage')
						multiNode = createNode('multiplyDivide')

						attr >> addNode.input3D[0].input3Dx
						multiNode.outputX >>  addNode.input3D[1].input3Dx
						#input1 saved for the meta animation
						input_attr = multiNode.input1X
						
						#create SDK
						inputStartValue = attrStartEnd[attr.name()][0]
						inputEndValue = attrStartEnd[attr.name()][1]
						
						con = input_attr.listConnections(s=1, d=0)
						if con: #if a connection already exists add another key into orig SDK animCurve
							animCurv = con[0]
							setKeyframe(animCurv, f=startValue, v = inputStartValue, itt='linear', ott='linear')
							setKeyframe(animCurv, f=startValue, v = inputEndValue, itt='linear', ott='linear')
							connectAttr(sdk_attr, animCurv.input, f=1)
						
						else:
							#startSDK
							sdk_attr.set(startValue)
							input_attr.set(inputStartValue)
							setDrivenKeyframe(input_attr, cd=sdk_attr, itt = 'linear', ott = 'linear', dv = startValue,v=inputStartValue, ib=0)
							
							#end SDK
							sdk_attr.set(endValue)
							input_attr.set(inputEndValue)
							setDrivenKeyframe(input_attr, cd=sdk_attr, itt = 'linear', ott = 'linear', dv = endValue,v=inputEndValue, ib=0)
							
							# Set the attribute back to the default value, if it doesn't
							# have one, assume 0
							value = addAttr(sdk_attr,q=1, dv=1)
							if value == None:
								value = 0
							sdk_attr.set(value)
							#sdk_attr.set(addAttr(sdk_attr,q=1, dv=1))
							
						#connect the addNode to the newAttr
						addNode.output3Dx >> newAttr
						
						connectToMeta(addNode, self.networkNode, 'SDKAdds')
						
						if multiply: #add Multiply Node 
							if not hasMultiply: #add Multiply node if one doesn't already exists
								animationCurve = input_attr.listConnections(s=1, d=0)[0]
								
								#create amplitude attribute
								multAttrName = sdk_attr.name().split(".")[-1] + "_multiply"
								sdk_attr.node().addAttr(multAttrName, keyable = 1, dv = 1)
								mult_attr = sdk_attr.node().attr(multAttrName)
								
								#create multiplyDivideNode
								multiNode = createNode('multiplyDivide', n = input_attr.name().replace(".", "_") + "amplitude")
								
								#connect amplitude Node
								connectAttr(animationCurve.output, multiNode.input1X, f=1)
								connectAttr(mult_attr, multiNode.input2X, f=1)
								connectAttr(multiNode.outputX, input_attr, f=1)
								
								
			#connect To MetaNode
			self.networkNode.setAttr('folder', sdkFolder, f=1)
			self.networkNode.setAttr('startPose', startPose, f=1)
			self.networkNode.setAttr('endPose', endPose, f=1)
			self.networkNode.setAttr('startValue', startValue, f=1)
			self.networkNode.setAttr('endValue', endValue, f=1)
			connectToMeta(node, self.networkNode, 'SDKNode')
			self.networkNode.setAttr('SDKAttrName', sdkAttrName, f=1)
	
	def toDefaultPose(self):
		node = self.networkNode.SDKNode.listConnections()[0]
		attrName = self.networkNode.SDKAttrName.get()
		attr = PyNode(node.name() + "." + attrName)
		value = addAttr(node,q=1, dv=1)
		if value == None:
			value = 0
		attr.set(value)
			
			
class EyeAimComponent(RigComponent):
	def __init__(self, leftEyeAnim, rightEyeAnim, direction, distance, side, bodyPart, node = None):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'EyeAimComponent'):
					self.networkNode = node
				else:
					printError("EyeAimComponent: node %s is not a EyeAimComponent metaNode"%(node))
			else:
				printError("EyeAimComponent: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'EyeAimComponent', 1.0, 'allows for eye aim on the rig', side, bodyPart, leftEyeAnim, rightEyeAnim)
			#create groups above anims
			direction = direction.upper()
			compName = "%s_%s"%(side, bodyPart)
			leftEyeAnim = PyNode(leftEyeAnim)
			rightEyeAnim = PyNode(rightEyeAnim)
			
			leftEyePar = leftEyeAnim.getParent()
			rightEyePar = rightEyeAnim.getParent()
			
			select(cl=1)
			left_anim_grp = group(n = leftEyeAnim.name() + "_aim_grp")
			parent(left_anim_grp, leftEyePar)
			alignPointOrient(leftEyeAnim, left_anim_grp,0,1)
			rot = left_anim_grp.rotate.get()
			left_anim_grp.rotate.set((0,0,0))
			pos = xform(leftEyeAnim, q=1, piv=1, ws=1)
			xform(left_anim_grp, piv=pos[:3], ws=1)
			left_anim_grp.rotateAxis.set(rot)
			parent(leftEyeAnim, left_anim_grp)
			
			select(cl=1)
			right_anim_grp = group(n = rightEyeAnim.name() + "_aim_grp")
			parent(right_anim_grp, rightEyePar)
			alignPointOrient(rightEyeAnim, right_anim_grp,0,1)
			rot = right_anim_grp.rotate.get()
			right_anim_grp.rotate.set((0,0,0))
			pos = xform(rightEyeAnim, q=1, piv=1, ws=1)
			xform(right_anim_grp, piv=pos[:3], ws=1)
			right_anim_grp.rotateAxis.set(rot)
			parent(rightEyeAnim, right_anim_grp)
			
			#make component groups
			select(cl=1)
			aimGrp = group(empty = 1, n = "%s_aim_grp"%compName)
			mainGrp = group(aimGrp,n = "%s_component_group"%compName)
			
			
			
			#make aim constraints
			direction = direction.upper()
			directionAttr = "translate" + direction
			
				#left aim anim
			select(cl=1)
			left_eye_aim_anim = joint(n = "left_eye_aim_anim")
			parent(left_eye_aim_anim, aimGrp)
			alignPointOrient(leftEyeAnim, left_eye_aim_anim,1,1)
			cube = polyCube()[0]
			alignPointOrient(left_eye_aim_anim, cube, 1,1)
			swapShape(left_eye_aim_anim, cube)
			
			addAnimAttr(left_eye_aim_anim)
			distVect = ( (direction == "X")*-distance,(direction == "Y")*-distance,(direction == "Z")*-distance) #bad assumption, assume left axis is negative for forward direction
			move(left_eye_aim_anim, distVect, os=1, r=1 )
			makeIdentity(left_eye_aim_anim, apply=1, t=1, r=1, s=1, n=1)
			left_eye_aim_anim.jointOrient.set((0,0,0))
			lockAndHideAttrs(left_eye_aim_anim, ['rx','ry','rz','sx','sy','sz','v', 'radius'])
			left_aim_grp = createZeroedOutGrp(left_eye_aim_anim)
			
			
				#right aim anim
			select(cl=1)
			right_eye_aim_anim = joint(n = "right_eye_aim_anim")
			parent(right_eye_aim_anim, aimGrp)
			alignPointOrient(rightEyeAnim, right_eye_aim_anim,1,1)
			cube = polyCube()[0]
			alignPointOrient(right_eye_aim_anim, cube, 1,1)
			swapShape(right_eye_aim_anim, cube)
			addAnimAttr(right_eye_aim_anim)
			distVect = ( (direction == "X")*distance,(direction == "Y")*distance,(direction == "Z")*distance) #bad assumption, assume right axis is positive for forward direction
			move(right_eye_aim_anim, distVect, os=1, r=1 )
			makeIdentity(right_eye_aim_anim, apply=1, t=1, r=1, s=1, n=1)
			right_eye_aim_anim.jointOrient.set((0,0,0))
			lockAndHideAttrs(right_eye_aim_anim, ['rx','ry','rz','sx','sy','sz','v', 'radius'])
			right_aim_grp = createZeroedOutGrp(right_eye_aim_anim)
			
				#both aim anim
			select(cl=1)
			both_eye_aim_anim = joint(n = "both_eye_aim_anim")
			parent(both_eye_aim_anim, aimGrp)
			pc = pointConstraint((left_eye_aim_anim, right_eye_aim_anim), both_eye_aim_anim, mo=0, w=1 )
			delete(pc)
			cube = polyCube()[0]
			alignPointOrient(both_eye_aim_anim, cube, 1,1)
			swapShape(both_eye_aim_anim, cube)
			lockAndHideAttrs(both_eye_aim_anim, ['rx','ry','rz','sx','sy','sz','v', 'radius'])
			addAnimAttr(both_eye_aim_anim)
			createZeroedOutGrp(both_eye_aim_anim)
			parent(left_aim_grp, both_eye_aim_anim)
			parent(right_aim_grp, both_eye_aim_anim)
				
				#create Constraint
			aimVector = ("X"==direction,"Y"==direction, 'Z'== direction)
			
			leftAimConst = aimConstraint(left_eye_aim_anim, left_anim_grp,mo=1,weight=1, aimVector=aimVector ,upVector =(0, 1, 0), worldUpType = "vector", worldUpVector= (0, 1, 0))
			rightAimConst  = aimConstraint(right_eye_aim_anim, right_anim_grp,mo=1,weight=1, aimVector=aimVector ,upVector =(0, 1, 0), worldUpType = "vector", worldUpVector= (0, 1, 0))
			
			#connectToMeta
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			connectToMeta(left_eye_aim_anim, self.networkNode, 'leftAnim')
			connectToMeta(right_eye_aim_anim, self.networkNode, 'rightAnim')
			connectToMeta(both_eye_aim_anim, self.networkNode, 'centerAnim')
			connectToMeta(left_anim_grp, self.networkNode, 'leftGrp')
			connectToMeta(right_anim_grp, self.networkNode, 'rightGrp')
			connectToMeta(aimGrp, self.networkNode, 'aimGrp')
			
	def getConnectObj(self, location):
		return self.networkNode.centerAnim.listConnections()[0]
	
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
	
	def getAllAnims(self):
		anims = []
		anims.append(self.networkNode.centerAnim.listConnections()[0])
		anims.append(self.networkNode.leftAnim.listConnections()[0])
		anims.append(self.networkNode.rightAnim.listConnections()[0])
		return anims
			
			
class NurbsFaceComponent(RigComponent):
	def __init__(self, locator, facePoly, node = ''):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		#test inputs
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'NurbsFaceComponent'):
					self.networkNode = node
				else:
					printError("NurbsFaceComponent: node %s is not a NurbsFaceComponent metaNode"%(node))
			else:
				printError("NurbsFaceComponent: node %s doesn't exist"%(node))
		else:
			if objExists(locator):
				locator = PyNode(locator)
				if not locator.getShape().type() == 'locator':
					printError("NurbsFaceComponent: %s isn't a locator"%locator)
			else:
				printError("NurbsFaceComponent: %s doesn't exist"%locator)
				
			if objExists(facePoly):
				facePoly = PyNode(facePoly)
				if not facePoly.getShape().type() == 'mesh':
					printError("FaceComponent: %s isn't a polygon"%facePoly)
			else:
				printError("NurbsFaceComponent: %s doesn't exist"%facePoly)
			
			
			#setup
			locName = locator.name()
			side = 'center'
			bodyPart = locName
			compName = '%s_%s'%(side, bodyPart)
			
			vertex = findClosestVertex(locator.getTranslation(space = 'world') ,facePoly)
			nurbs = createNurbsOnVertex(vertex)
			retObjs = createJointsOnNurbs(nurbs)
			wrapObj(nurbs, facePoly)
				
			baseJoint = retObjs[0] 
			tipJoint = retObjs[1]
			baseLoc = retObjs[2]
			control = retObjs[3]
			posInfo = retObjs[4]
			pointGrp = retObjs[5]
			
			baseJoint.rename('face_%s_base_joint'%bodyPart)
			tipJoint.rename('face_%s_tip_joint'%bodyPart)
			baseLoc.rename('face_%s_base_locator'%bodyPart)
			control.rename('face_%s_control_locator'%bodyPart)
			posInfo.rename('face_%s_pos_info'%bodyPart)
			pointGrp.rename('face_%s_translate_group'%bodyPart)
			nurbs.rename('face_%s_nurbs_plane'%bodyPart)
			
			nurbs.hide()
			locator.hide()
			
			#call RIG Component
			RigComponent.__init__(self, 'NurbsFaceComponent', 1.0, 'a joint on burbs component for the face', side, bodyPart, baseJoint, tipJoint)
	
			#organize
			select(cl=1)
			jointGrp = group([baseJoint],n='%s_joint_grp'%compName)
			animGrp = group([baseLoc], n = "%s_anim_grp"%compName)
			dntGrp = group([locator, nurbs, pointGrp], n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_face_component_group"%compName)
					
			#connect to meta
			connectToMeta(locator, self.networkNode, 'initialLoc')
			connectToMeta(nurbs, self.networkNode, 'nurbs')
			connectToMeta(retObjs[0], self.networkNode, 'nurbsJoint')
			connectToMeta(retObjs[1], self.networkNode, 'bindJoint')
			connectToMeta(retObjs[2], self.networkNode, 'baseLoc')
			connectToMeta(retObjs[3], self.networkNode, 'controlLoc')
			connectToMeta(retObjs[4], self.networkNode, 'pointOnSurface')
			connectToMeta(retObjs[5], self.networkNode, 'TranslateGroup')
			connectToMeta(mainGrp, self.networkNode, 'mainGroup' )

class StretchyJointChain(RigComponent):
	def __init__(self, startDistance, endDistance, side, bodyPart, startJoint, endJoint,node = None):
		'''
		numSegments:
			the number of segments to split chain, animCount = numSegments - 1
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'StretchyJointChain'):
					self.networkNode = node
				else:
					printError("StretchyJointChain: node %s is not a StretchyJointChain metaNode"%(node))
			else:
				printError("StretchyJointChain: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'StretchyJointChain', 1.0, 'a foot rig, with many types of movement', side, bodyPart, startJoint, endJoint)
			compName = '%s_%s'%(side, bodyPart)
			
			chain = chainBetween(startJoint, endJoint)
			numSegments = len(chain)-2
			
			#create control joints
			controlJoints = duplicateChain(startJoint, endJoint, 'bind', 'control')
			controlJoints = map(lambda x: PyNode(x), controlJoints)
			bindJoints = chainBetween(startJoint, endJoint)
			bindJoints = map(lambda x: PyNode(x), bindJoints)
			transformJoints = duplicateChain(startJoint, endJoint, 'bind','transform')
			
				#rename
			for x in xrange(len(controlJoints)):
				controlJoints[x].rename("%s_%i_control_joint"%(compName, x+1))
			
			#create distances
			startLoc = spaceLocator(p=(0,0,0))
			endLoc = spaceLocator(p=(0,1,0))
			currentLength = PyNode(distanceDimension(sp = (0,0,0), ep = (0,1,0)))
			alignPointOrient(startDistance, startLoc, 1, 1)
			alignPointOrient(endDistance, endLoc, 1,1)
			parentConstraint(startDistance, startLoc, mo=0, w=1)
			parentConstraint(endDistance, endLoc, mo=0, w=1)
			parentConstraint(startJoint, transformJoints[0], mo=1,w=1)
			origTotal = 0
			for t in transformJoints[1:]:
				origTotal += t.translateX.get()
			oldRatio = 0
			for t in transformJoints[1:]: 
				#get transslate to move with stretchy
				ratioMulti = createNode('multiplyDivide') #startjointDist/ origTotalDistance
				ratioMulti.operation.set(2)
				ratioMulti.input2X.set(origTotal)
				ratioMulti.input1X.set(abs(t.translateX.get()))
				outputMulti = createNode('multiplyDivide')
				ratioMulti.outputX >> outputMulti.input1X
				currentLength.distance >> outputMulti.input2X
				outputMulti.outputX >> t.translateX
				#gets rotate to smooth rotations
				ratio = abs(ratioMulti.outputX.get())+oldRatio
				print ratio
				revRatio = 1-ratio
				if revRatio < 0:
					revRatio = 0
				orConst = PyNode(orientConstraint([startDistance, endDistance], t,skip=('z',"y"), mo=0))
				orConst.w0.set(revRatio)
				orConst.w1.set(ratio)
				oldRatio += abs(ratioMulti.outputX.get())
				
				
			#create anims
			zeroGrps =[]
			anims = []
			for num in xrange(numSegments):
				select(clear=1)
				anim = joint(n = '%s_anim_%i'%(compName,num+1))
				alignPointOrient(controlJoints[num+1], anim, 1,1)
				zeroGrp = createZeroedOutGrp(anim)
				addAnimAttr(anim)
				cube = polyCube()[0]
				appendShape(cube, anim)
				delete(cube)
				lockAndHideAttrs(anim, [ 'v', 'radius', 'sx', 'sy', 'sz'])
				anims.append(anim)
				zeroGrps.append(zeroGrp)
			
			#connectDistances
			for num in xrange(numSegments):
				pointConstraint(transformJoints[num+1], zeroGrps[num], mo =1)
				orientConstraint(transformJoints[num+1], zeroGrps[num], mo =1)
			
			#connect anims
			for x in xrange(numSegments):
				parentConstraint(anims[x],controlJoints[x+1], w=1, mo=1)
			
			#connect bindJoints
			for x in xrange(len(controlJoints)-1):
				parentConstraint(controlJoints[x], bindJoints[x], w=1, mo=1)
			
			#grouping
			select(cl=1)
			jointGrp = group([controlJoints[0], transformJoints[0]],n='%s_joint_grp'%compName)
			animGrp = group([zeroGrps], n = "%s_anim_grp"%compName)
			dntGrp = group([startLoc, endLoc,currentLength], n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
			
			#hide
			dntGrp.hide()
			jointGrp.hide()
			
			#connectToMeta
			connectChainToMeta(bindJoints, self.networkNode, 'bindJoints')
			connectChainToMeta(controlJoints, self.networkNode, 'controlJoints')
			connectChainToMeta(anims, self.networkNode, 'anims')
			connectToMeta(dntGrp, self.networkNode, 'dntGrp')
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
			
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		if other == self:
			pass
		else:
			thisAnims = self.getAllAnims()
			otherAnims = other.getAllAnims()
			if bothSides: #copy over from other side, then copy this side to that side
				for x in xrange(len(otherAnims)):
					#get
					otherAnim = otherAnims[x]
					otherTrans = otherAnim.translate.get()
					otherRotate = otherAnim.rotate.get()
					thisAnim = thisAnims[x]
					thisTrans = thisAnim.translate.get()
					thisRotate = thisAnim.rotate.get()
					
					#set
					thisAnim.translate.set(otherTrans[0], otherTrans[1], -otherTrans[2])
					thisAnim.rotate.set(-otherRotate[0], -otherRotate[1], otherRotate[2])
					otherAnim.translate.set(thisTrans[0], thisTrans[1], -thisTrans[2])
					otherAnim.rotate.set(-thisRotate[0], -thisRotate[1], thisRotate[2])
				return [self, other]
			else:# just copy over from other side
				for x in xrange(len(otherAnims)):
					otherTrans = otherAnims[x].translate.get()
					otherRotate = otherAnims[x].rotate.get()
					thisAnim = thisAnims[x]
					thisAnim.translate.set(otherTrans[0], otherTrans[1], -otherTrans[2])
					thisAnim.rotate.set(-otherRotate[0], -otherRotate[1], otherRotate[2])
				return [self]	
				
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
		
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		raise Exception("can't connect to this component getConnectObj() not implemented, %s"%self.networkNode.metaType.get())
			
	def getBindJoints(self):
		'''
		return the joints which should be bound to
		'''
		try:
			return self.networkNode.bindJoints.listConnections()[1:-1]
		except:
			return None 
	
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		return self.networkNode.anims.listConnections()
		
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''			
		anims = self.getAllAnims()
		for anim in anims:
			anim.translate.set([0,0,0])
			anim.rotate.set([0,0,0])
						
class AdvancedFoot(RigComponent):
	def __init__(self, heelJoint, toeJoint, insideJoint, outsideJoint, side, bodyPart, startJoint, endJoint, node = None):
		'''
		heelJoints:
			a joint placed at the heel location
		toeJoint:
			a joint placed at the toe of the character
		outisdeJoint:
			a joint placed on the outside of the foot, side of foot farthest from other body center
		insideJoint:
			a joint placed on the inside of the foot, side of foot closest to the body center
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'AdvancedFoot'):
					self.networkNode = node
				else:
					printError("AdvancedFoot: node %s is not a AdvancedFoot metaNode"%(node))
			else:
				printError("AdvancedFoot: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'AdvancedFoot', 1.0, 'a foot rig, with many types of movement', side, bodyPart, startJoint, endJoint)
			chain = chainBetween(startJoint, endJoint)
			bind_joints = []
			compName = '%s_%s'%(side, bodyPart)
			for item in chain:
				item  = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
			
			#test pivot joints
			if not objExists(heelJoint):
				raise Exception("AdvanceFoot.__init__: obj given as heelJoint, %s, doesn't exist"%heelJoint)		
			if not objExists(toeJoint):
				raise Exception("AdvanceFoot.__init__: obj given as toeJoint, %s, doesn't exist"%toeJoint)
			if not objExists(insideJoint):
				raise Exception("AdvanceFoot.__init__: obj given as insideJoint, %s, doesn't exist"%insideJoint)
			if not objExists(outsideJoint):
				raise Exception("AdvanceFoot.__init__: obj given as outsideJoint, %s, doesn't exist"%outsideJoint)
				
			#make pivot joints PyNodes
			heelJoint = PyNode(heelJoint)
			toeJoint = PyNode(toeJoint)
			insideJoint = PyNode(insideJoint)
			outsideJoint = PyNode(outsideJoint)
					
			control_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'control')

			#create iks
			foot_ik = ikHandle( sj= control_joints[0], ee = control_joints[1], sol ='ikSCsolver')[0]
			ball_ik = ikHandle( sj= control_joints[1], ee = control_joints[-1], sol ='ikSCsolver')[0]
			
			#create ball and wiggle joints
			select(cl=1)
			ballJoint = duplicate(control_joints[1], n = '%s_ball_joint'%compName)[0]
			delete(ballJoint.getChildren())
			select(cl=1)
			wiggleJoint = duplicate(control_joints[1], n = '%s_wiggle_joint'%compName)[0]
			delete(ballJoint.getChildren())
			
			#orient pivot joints to foot ball to match rotation
			for x in [heelJoint, toeJoint, insideJoint, outsideJoint, ballJoint, wiggleJoint]:
				alignPointOrient(control_joints[1], x, 0, 1)
				makeIdentity(x,apply = 1, t=0,r=1, s=1,n=0)
			
			#create Anim
			select(clear=1)
			anim = joint(n = '%s_anim'%compName)
			alignPointOrient(startJoint, anim, 1,1)
			zeroGrp = createZeroedOutGrp(anim)
			addAnimAttr(anim)
			cube = polyCube()[0]
			appendShape(cube, anim)
			delete(cube)
			lockAndHideAttrs(anim, ['tx','ty', 'tz', 'v', 'radius', 'sx', 'sy', 'sz'])
			
			#create attrs on anim
			anim.addAttr('roll', keyable=1,dv =0)
			anim.addAttr('toeLift',  keyable=1,dv = 15)
			anim.addAttr('toeStraight',  keyable=1,dv = 50)
			anim.addAttr('lean',  keyable=1,dv = 0)
			anim.addAttr('tilt', keyable=1, dv = 0)
			anim.addAttr('toeSpin',  keyable=1, dv = 0)
			anim.addAttr('toeWiggle', keyable=1, dv = 0)
			anim.addAttr('heelSpin',  keyable=1,dv = 0)
			
			#parenting
			anim | heelJoint
			heelJoint | toeJoint
			toeJoint | outsideJoint
			outsideJoint | insideJoint
			insideJoint | ballJoint
			ballJoint | wiggleJoint
			wiggleJoint | ball_ik
			insideJoint | foot_ik
			
			exprStr = '''
				$roll = %s.roll;
				$toeLift = %s.toeLift;
				$toeStraight = %s.toeStraight;
				$lean = %s.lean;
				$side = %s.tilt;
				$toeSpin = %s.toeSpin;
				$wiggle = %s.toeWiggle;
				$heelSpin = %s.heelSpin;
				
				%s.rotateZ = max(-$roll,0);
				%s.rotateZ = (linstep(0, $toeLift,$roll)) * (1-(linstep($toeLift, $toeStraight, $roll))) * -$roll;
				%s.rotateZ = linstep($toeLift, $toeStraight, $roll) * -$roll;
				%s.rotateX = -$lean;
				%s.rotateX = min(-$side,0);
				%s.rotateX = max(-$side,0);
				
				%s.rotateY = -$toeSpin;
				%s.rotateZ = $wiggle + (linstep(0, $toeLift,$roll)) * (1-(linstep($toeLift, $toeStraight, $roll))) * $roll;
				%s.rotateY = $heelSpin;
			'''%(anim, anim, anim, anim, anim, anim, anim, anim, heelJoint, ballJoint, toeJoint, ballJoint, outsideJoint, insideJoint, toeJoint, wiggleJoint, heelJoint)
			
			
			expr = expression(s=exprStr, n = '%s_expression'%compName,ae=1, uc='all')
			
			#bindJoints
			for j in xrange(len(bind_joints)-1):
				parentConstraint(control_joints[j], bind_joints[j], w=1, mo=1)
			
			#grouping
			select(cl=1)
			jointGrp = group([control_joints[0]],n='%s_joint_grp'%compName)
			animGrp = group([zeroGrp], n = "%s_anim_grp"%compName)
			dntGrp = group(empty = 1, n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
			
			#hide
			dntGrp.hide()
			control_joints[0].hide()
			heelJoint.hide()
			
			#connectToMeta
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
			connectChainToMeta(control_joints, self.networkNode, 'controlJoints')
			connectToMeta(foot_ik, self.networkNode, 'footIK')
			connectToMeta(ball_ik, self.networkNode, 'ballIK')
			connectToMeta(heelJoint, self.networkNode, 'heelJoint')
			connectToMeta(toeJoint, self.networkNode, 'toeJoint')
			connectToMeta(insideJoint, self.networkNode, 'insideJoint')
			connectToMeta(outsideJoint, self.networkNode, 'outsideJoint')
			connectToMeta(ballJoint, self.networkNode, 'ballJoint')
			connectToMeta(wiggleJoint, self.networkNode, 'wiggleJoint')
			connectToMeta(anim, self.networkNode, 'anim')
			connectToMeta(dntGrp, self.networkNode, 'dntGrp')
			connectToMeta(zeroGrp, self.networkNode, 'zeroAnimGrp')
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
					
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		
		#############################################################################3
		## WARNING CURRENTLY ONLY ABLE TO HANDLE CONNECTING TO FKIKCHAINS
		##############################################################################
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		scaleConstraint(obj, mainGrp, w=1, mo = 1)
		
		if comp.isIK():
			ikHandle = comp.getIK()
			zeroGrp = self.networkNode.zeroAnimGrp.listConnections()[0]
			zeroGrp.inheritsTransform.set(0)
			parentConstraint(self.networkNode.ballJoint.listConnections()[0], ikHandle, w=1, mo=1)			
			
			## FKIKChain only
			ikLoc = spaceLocator()
			fkLoc = spaceLocator()
			ik = comp.networkNode.ikAnim.listConnections()[0]
			fk = comp.networkNode.FKJoints.listConnections()[-1]
			pointConstraint(ik, ikLoc, w=1, mo=0)
			pointConstraint(fk, fkLoc, w=1, mo=0)
			ikLoc.inheritsTransform.set(0)
			fkLoc.inheritsTransform.set(0)
			dntGrp = self.networkNode.dntGrp.listConnections()[0]
			parent(ikLoc, fkLoc, dntGrp)
			switch = comp.networkNode.switchGroup.listConnections()[0]
			switchAttr = switch.attr(comp.networkNode.switchAttr.get())
			
			const = parentConstraint([fkLoc, ikLoc], zeroGrp, w=1, mo=1)
			switchAttr >> const.w1
			rev = createNode('reverse')
			switchAttr >> rev.inputX
			rev.outputX >> const.w0
			lockAndHideAttrs(ik, ['rx', 'ry','rz'])
			
			#parentConstraint(obj, zeroGrp, w=1, mo=1)
		
		
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.controlJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.controlJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("AdvancedFoot.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			control_joints = self.networkNode.FKJoints.listConnections()
			for inc in xrange(len(bind_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return control_joints[inc]
				if location == control_joints[inc]:
					return control_joints[inc]
		raise Exception("AdvancedFoot.getConnectObj: location wasn't found, try 'start', 'end', or name of bind or control joint ")	
	
	def getAnim(self):
		'''
		returns the anim with all the rotation information
		'''	
		return self.networkNode.anim.listConnections()[0]
	
	def getAllAnims(self):
		'''
		returns a list of all the anims
		'''
		return [self.getAnim()]
		
	def toDefaultPose(self):
		'''
		moves the component into the bind position
		'''		
		resetAttrs(self.getAnim())	
			
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		character = self.getCharacterRig()
		other = character.getOppositeComponent(self)
		if other == self:
			anim = self.getAnim()
			anim.rotateX.set(anim.rotateX.get()*-1)
			anim.rotateY.set(anim.rotateY.get()*-1)
			return [self]
		else:
			anim = self.getAnim()
			attrs = anim.listAttr(keyable = 1)
			attrValue = {}
			attrs = map(lambda x: x.name().split(".")[-1], attrs)
			for x in attrs:
				attrValue[x] = anim.attr(x).get()
			otherAnim = other.getAnim()
			otherAttrs = otherAnim.listAttr(keyable = 1)
			otherAttrs = map(lambda x: x.name().split(".")[-1], otherAttrs)
			otherAttrValue = {}	
			for x in otherAttrs:
				otherAttrValue[x] = otherAnim.attr(x).get()
			if bothSides:
				for attr in attrs:
					otherAnim.attr(attr).set(attrValue[attr])
				for attr in otherAttrs:
					anim.attr(attr).set(otherAttrValue[attr])
				return [self, other]
			else:
				for attr in otherAttrs:
					anim.attr(attr).set(otherAttrValue[attr])
			return [self]
		
class DynamicChain(RigComponent):
	def __init__(self, side, bodyPart, startJoint, endJoint, node = ''):
		'''
		side:
			the side is this component on, ex. center, left, right
		bodyPart:
			the body part the component is for, ex. arm, leg, clavicle, foot
		startJoint:
			the place where the component starts
		endJoint:
			the place where the component end
		'''
		
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'DynamicChain'):
					self.networkNode = node
				else:
					printError("DynamicChain: node %s is not a DynamicChain metaNode"%(node))
			else:
				printError("DynamicChain: node %s doesn't exist"%(node))
		else:
			RigComponent.__init__(self, 'DynamicChain', 1.0, 'a joint chain which is influenced by Dynamics',side, bodyPart, startJoint, endJoint)
			chain = chainBetween(startJoint, endJoint)
			bind_joints = []
			compName = '%s_%s'%(side, bodyPart)
			for item in chain:
				item  = PyNode(item)
				if item.type() == 'joint':
					bind_joints.append(item)
			
			#create Joint chains
			dyn_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'dynamic')
			control_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'control')
			fk_joints = duplicateChain(bind_joints[0], bind_joints[-1], 'bind', 'dynFK')
					
			#create dynamic system
			origCurve = self.createCurveFromObjects(bind_joints)
			origCurve.rename('%s_orig_curve'%compName)
			
			select(origCurve, r=1)
			rt.MakeCurvesDynamic(1, 0,1)
			follicle = listConnections(origCurve.getShape().worldSpace[0])[0]
			follicle.rename('%s_follicle'%compName)
			hair = listConnections(follicle.outHair)[0]
			hair.rename('%s_hair_system'%compName)
			dynCurve = listConnections(follicle.outCurve)[0]
			
			dynCurve.rename('%s_dyn_curve'%compName)
			origCurve.inheritsTransform.set(0)
			b = dynCurve.getParent()
			parent(dynCurve, w=1)
			delete(b);
			
			#create anim 
			select(cl=1)
			animJoint = joint(n = '%s_dyn_anim'%compName)
			addAnimAttr(animJoint)
			p = polySphere()[0]
			appendShape(p, animJoint)
			delete(p) 
			alignPointOrient(dyn_joints[-1], animJoint, 1,1)
			pointConstraint(dyn_joints[-1], animJoint, mo=1, w=1)
			zeroGrp = createZeroedOutGrp(animJoint)
			
			
			#add attrs to anim
			animJoint.addAttr('enable', min = 0, max =1, dv = 1, keyable = 0)
			animJoint.enable.set(channelBox=1)
			animJoint.addAttr('stiff', min =0 , max =1 , dv =.001, keyable =1)
			animJoint.addAttr('lengthFlex', min =0 , max =1 , dv =0, keyable =1)
			animJoint.addAttr('damping', min =0 , max =100 , dv =0, keyable =1)
			animJoint.addAttr('drag', min =0 , max =1 , dv =.5, keyable =1)
			animJoint.addAttr('friction', min =0 , max =1 , dv =.5, keyable =1)
			animJoint.addAttr('gravity', min =0 , max =10 , dv =1, keyable =1)
			animJoint.addAttr('turbulenceCtrl', at = 'bool', keyable =1)
			animJoint.turbulenceCtrl.lock()
			animJoint.addAttr('strength', min =0 , max =1 , dv =0, keyable =1)
			animJoint.addAttr('frequency', min =0 , max =2 , dv =.2, keyable =1)
			animJoint.addAttr('speed', min =0 , max =2 , dv =.2, keyable =1)
	
			#set enable/disable
			animJoint.enable.set(0)
			follicle.getShape().simulationMethod.set(0)
			setDrivenKeyframe(follicle.getShape().simulationMethod,cd = animJoint.enable)
			animJoint.enable.set(1)
			follicle.getShape().simulationMethod.set(2)
			setDrivenKeyframe(follicle.getShape().simulationMethod,cd = animJoint.enable)
			
			#connect up dynamics
			follicle.overrideDynamics.set(1)
			follicle.pointLock.set(1)
			animJoint.stiff >> follicle.stiffness
			animJoint.lengthFlex >> follicle.lengthFlex
			animJoint.damping >> follicle.damp
			animJoint.drag >> hair.drag
			animJoint.friction >> hair.friction
			animJoint.gravity >> hair.gravity
			animJoint.strength >> hair.turbulenceStrength
			animJoint.frequency >> hair.turbulenceFrequency
			animJoint.speed >> hair.turbulenceSpeed
			
			lockAndHideAttrs(animJoint, ['tx','ty','tz','rx','ry','rz','sx','sy','sz', 'radius'])
			animJoint.v.set(keyable = 0)
			
			#create ik spline
			b = ikHandle(c = dynCurve, startJoint = dyn_joints[0], endEffector = dyn_joints[-1], sol = 'ikSplineSolver', w=1, ccv=0)
			ik = b[0]
			ik.rename('%s_ik_curve'%compName)
			eff = b[1]
			
			#switch Grp
			switchGrp = group(empty = 1, n =  "%s_switch_grp"%compName)
			switchGrp.addAttr('fk_dyn_switch', min = 0, max =1, dv = 1)
			
			rev = createNode('reverse')
			switchGrp.fk_dyn_switch >> rev.inputX
			
			#create fk anims
			for inc in xrange(len(fk_joints)-1):
				obj = fk_joints[inc]
				addBoxToJoint(obj)
				lockAndHideAttrs(obj, ['tx', 'ty', 'tz', 'sx', 'sy', 'sz', 'radius'])
				obj.v.set(keyable = 0)
				addAnimAttr(obj)
				obj.rename('%s_%s_%i_anim'%(getJointLabels(obj)[0], getJointLabels(obj)[1], inc))
			
			#connect to control joints
			for inc in xrange(len(control_joints)):
				const = parentConstraint([fk_joints[inc], dyn_joints[inc]], control_joints[inc], mo=1, w=1)
				switchGrp.fk_dyn_switch >> const.w1
				rev.outputX >> const.w0	
						
			#connect to bind joints
			for inc in xrange(len(bind_joints)-1):
				parentConstraint(control_joints[inc], bind_joints[inc], mo=1, w=1)
			
			#grouping
			select(cl=1)
			jointGrp = group([fk_joints[0], control_joints[0], dyn_joints[0]],n='%s_joint_grp'%compName)
			animGrp = group([zeroGrp], n = "%s_anim_grp"%compName)
			dntGrp = group([switchGrp, dynCurve, ik, hair, follicle.getParent()], n = "%s_DO_NOT_TOUCH_grp"%compName)
			mainGrp = group([jointGrp, animGrp, dntGrp],n = "%s_component_group"%compName)
			xform(mainGrp, piv = bind_joints[0].getTranslation(space = 'world'), ws=1)
			
			#hide
			dntGrp.hide()
			control_joints[0].hide()
			rev.outputX >> fk_joints[0].v
			switchGrp.fk_dyn_switch >> zeroGrp.v
			switchGrp.fk_dyn_switch >> dyn_joints[0].v
			
			#connectToMeta
			connectChainToMeta(bind_joints, self.networkNode, 'bindJoints')
			connectChainToMeta(dyn_joints, self.networkNode, 'dynamicJoints')
			connectChainToMeta(control_joints, self.networkNode, 'controlJoints')
			connectChainToMeta(fk_joints, self.networkNode, 'FKJoints')
			connectToMeta(follicle, self.networkNode, 'follicle')
			connectToMeta(hair, self.networkNode, 'hair')
			connectToMeta(animJoint, self.networkNode, 'dynAnim')
			connectToMeta(switchGrp, self.networkNode, 'switchGroup')		
			self.networkNode.setAttr('switchAttr', 'fk_dyn_switch',  f=1)
			connectToMeta(origCurve, self.networkNode, 'originalCurve')
			connectToMeta(dynCurve, self.networkNode, 'dynamicCurve')
			connectToMeta(mainGrp, self.networkNode, 'componentGrp')
		
	def createCurveFromObjects(self, objects):
		'''
		creates a curve through the objs
		return:
			the new curve
		'''
		points = []
		for obj in objects:	
			points.append(obj.getTranslation(space = 'world'))
			
		degree = 3
		degree = min(degree, len(points))
		c =curve(ep = points,d= degree )
		
		return PyNode(c)
			
	def collideWith(self, objects):
		'''
		make dynamic chain collide with obj(s)
		'''
		hair = listConnections(self.networkNode.hair)[0].getShape()
		time = PyNode('time1')
		
		#make objects into a list
		if not type(objects) is list or not type(objects) is tuple:
			objects = [objects]
		
		for obj in objects:
			
			#test obj
			if not objExists(obj):
				raise Exception("DynamicChain.collideWith: obj given, %s, doesn't exist"%obj)
			obj = PyNode(obj)
			shape = obj.getShape()
			geoLink = createNode('geoConnector')
			
			#connect shape to connector
			shape.message >> geoLink.owner
			shape.worldMatrix[0] >> geoLink.worldMatrix
			shape.outMesh >> geoLink.localGeometry
			connectAttr(geoLink.resilience, hair.collisionResilience, na =1)
			connectAttr(geoLink.friction, hair.collisionFriction, na=1)
			connectAttr(geoLink.sweptGeometry, hair.collisionGeometry, na=1)
			time.outTime >> geoLink.currentTime
		
	def bake(self):
		'''
		bakes the dynamic chain into a fk joint chain for further animation
		'''
		#get variables from node
		fk_joints = listConnections(self.networkNode.FKJoints)
		dyn_joints = listConnections(self.networkNode.dynamicJoints)
		switchGrp = self.networkNode.switchGroup.listConnections()[0]
		switchAttr = switchGrp.attr(self.networkNode.switchAttr.get())
		dynAnim = self.networkNode.dynAnim.listConnections()[0]
		
		#create orientConstraints
		consts = []
		
		for inc in xrange(len(fk_joints)):
			const = orientConstraint(dyn_joints[inc], fk_joints[inc], w=1, mo=0)
			consts.append(const)
			
		#bake the fk_joints
		startTime = playbackOptions(min=1, q=1)
		endTime = playbackOptions(max=1, q=1)
		bakeResults ( fk_joints,simulation=1, t=(startTime,endTime), sb=1, at=["rx","ry","rz"], hi="none")
	
		#delete constraints
		map(lambda x: delete(x), consts)
		
		#switch to the fk joints
		switchAttr.set(0)
		
		#disable dyn Joints
		dynAnim.enable.set(0)
		
	def unbake(self):
		'''
		if baked, then will turn delete keys on fk chain and turn to dynamic chain
		'''
		#get variables from node
		fk_joints = listConnections(self.networkNode.FKJoints)
		dyn_joints = listConnections(self.networkNode.dynamicJoints)
		switchGrp = self.networkNode.switchGroup.listConnections()[0]
		switchAttr = switchGrp.attr(self.networkNode.switchAttr.get())
		dynAnim = self.networkNode.dynAnim.listConnections()[0]
		
		#delete all keys on fk_joints
		startTime = playbackOptions(min=1, q=1)
		endTime = playbackOptions(max=1, q=1)
		for j in fk_joints:
			cutKey(j, animation = 'objects' ,clear=1)
		
		#switch to the fk joints
		switchAttr.set(1)
		
		#disable dyn Joints
		dynAnim.enable.set(1)
			
	def connectToComponent(self, comp, location, point=1, orient =1):
		'''
		connects this component to the other component
		comp:
			the component to attach to
		location:
			the place where the components connect, ex, start, end, jointName
		point:
			attach by translation
		orient:
			attach by orientation
		'''
		obj = comp.getConnectObj(location)
		mainGrp = self.networkNode.componentGrp.listConnections()[0]
		skipRot = ['x','y','z']
		skipTrans = ['x','y','z']
		if point:
			skipTrans = []
		if orient:
			skipRot = []	
		parentConstraint(obj, mainGrp, sr = skipRot, st = skipTrans,w=1, mo=1)
		#scaleConstraint(obj, mainGrp, w=1, mo = 1)
			
	def getConnectObj(self, location):
		'''
		gets the component to connect to at location
		location:
			the location to connect to
		return:
			the obj which others can connect to
		'''
		if location == 'start':
			return self.networkNode.controlJoints.listConnections()[0]
		elif location == 'end':
			return self.networkNode.controlJoints.listConnections()[-1]
		else: # an object
			if not objExists(location):
				raise Exception("DynamicChain.getConnectObj: location obj,%s , doesn't exist"%location)
			location = PyNode(location)
			bind_joints = self.networkNode.bindJoints.listConnections()
			control_joints = self.networkNode.controlJoints.listConnections()
			fk_joints = self.networkNode.FKJoints.listConnections()
			dyn_joints = self.networkNode.dynamicJoints.listConnections()
			for inc in xrange(len(bind_joints)):# test for a bind joint
				if location == bind_joints[inc]:
					return control_joints[inc]
				if location == control_joints[inc]:
					return control_joints[inc]
				if location == fk_joints[inc]:
					return control_joints[inc]
				if location == dyn_joints[inc]:
					return control_joints[inc]
		raise Exception("DynamicChain.getConnectObj: location wasn't found, try 'start', 'end', or name of bind ,fk, ik, or control joint ")
	
		
	def isFK(self):
		return True
		
	def getAllAnims(self):
		return [self.getDynamicAnim()]
		
	def getDynamicAnim(self):
		'''
		returns the anim that controls the dynamics
		'''
		return self.networkNode.dynAnim.listConnections()[0]
		
	def mirror(self, bothSides = 0):
		'''
		mirrors the component
		bothSides:
			 if True, mirrors the others side as well
		return a list components Mirrored
		'''
		return [self]
		
		
	def getFKAnims(self):
		'''
		returns all the FK anims, used when dynamic is baked
		'''
		return self.networkNode.FKJoints.listConnections()[:-1]
		
class MultiConstraint(MetaNode):
	def __init__(self, targets, object, node=None):
		'''
		targets:
			the parents in the relationship
		obj:
			the child of the constraint
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'MultiConstraint'):
					self.networkNode = node
				else:
					printError("MultiConstraint: node %s is not a MultiConstraint metaNode"%(node))
			else:
				printError("MultiConstraint: node %s doesn't exist"%(node))
			
		else:
			MetaNode.__init__(self, 'MultiConstraint', 1.0, 'creates multi parents on obj with easy switch ability')
			self.create(targets, object)
		
	def isActive(self):
		'''
		return true if constraint is currently working on object
		'''
		try:
			return self.networkNode.active.get()
		except:
			return None
			
	def create(self, targets, object):
		'''
		targets:
			the parents in the relationship
		obj:
			the child of the constraint
		'''
		if not (type(targets) is list or type(targets) is tuple):
			targets = [targets]
			
		#error test		
		for target in targets:
			if not objExists(target):
				raise Exception("MultiConstraint.__init__(): given target ,%s,  doesnt exists"%target)
		if not objExists(object):
			raise Exception("MultiConstraint.__init__(): given target ,%s,  doesnt exists"%object)
		
		targets = map(lambda x: PyNode(x), targets)
		object = PyNode(object)
				
		multiGrp = group(object, n="%s_mulitConst_grp"%object)
		multiGrp.rotateOrder.set(object.rotateOrder.get())
		#make the parentConstraints
		parentConst = parentConstraint(targets, multiGrp, mo = 1, w=0)
		
		#add the parent attr
		targetEnum = ':'
		strTargets = map(lambda x: x.name(), targets)
		targetEnum = targetEnum.join(strTargets)

		targetEnum += ":NONE"
		addAttr(multiGrp, ln = 'parent', at = 'enum', en = targetEnum)
		
		#add same parent attr to obj just for display and visible parent for animator
		object.addAttr('parent', at = 'enum', en = targetEnum, keyable = 1)
		multiGrp.parent >> object.parent
		object.parent.lock()
		
		
		#make set driven keys for parent attr
		driver = multiGrp.name() + ".parent"
		for target in xrange(len(targets)+1):
			setAttr(driver, target)
			for inc in xrange(len(targets)):
				driven = parentConst.name() + ".w" + str(inc)
				if(target == inc):
					setAttr(driven, 1)
				else:
					setAttr(driven, 0)
				setDrivenKeyframe(driven, currentDriver = driver)
		
		
		#connect To meta
		connectChainToMeta(targets, self.networkNode, 'targets')
		connectToMeta(object, self.networkNode, 'object')
		connectToMeta(multiGrp, self.networkNode, 'multiConstGrp')
		connectToMeta(parentConst, self.networkNode, 'constraint')
		self.networkNode.setAttr('active', 1, f=1)
		
		
	def swapMultiConstraint(self,constNum):
		'''
		swaps current parent with parent of the constraint number
		object: 
			the child of the parent constraints
		constNum: 
			constraint number, an integer from 0-(num of parents), (num of parents) = NONE.
		'''
		if not self.isActive():
			raise Exception("MultiConstraint.swapMultiConstraint: multiConstraint is not active")
		obj = self.networkNode.object.listConnections()[0]
		
		trans = xform(obj, q=1, ws=1, piv=1)
		rot = xform(obj, q=1, ws=1, ro=1)
		
		multiGrp = self.networkNode.multiConstGrp.listConnections()[0]
		setAttr(multiGrp.name() + ".parent", constNum);
		move(obj, trans[0], trans[1], trans[2], rpr=1)
		rotate(obj, rot[0], rot[1], rot[2], ws=1)

	def removeMultiConstraint(self):
		'''
		Removes the multiConstraint from the object
		'''	
		if not self.isActive():
			raise Exception("MultiConstraint.removeMultiConstraint: multiConstraint is not active")
		
		#delete constraint
		delete(self.networkNode.constraint.listConnections()[0])
		
		#reparent the groups children
		multiGrp = self.networkNode.multiConstGrp.listConnections()[0]
		children = multiGrp.getChildren()
		par = multiGrp.getParent()
		for child in children:
			if(par == None):
				parent(child, world=1)
			else:
				parent(child, parent)
		delete(multiGrp)
		#delete objects parent attr
		object = self.networkNode.object.listConnections()[0]
		object.parent.unlock()
		deleteAttr(object + ".parent")
		
		self.networkNode.active.set(0)

	def delete(self):
		self.removeMultiConstraint()
		delete(self.networkNode)
		
	def addMultiConstraintTarget(self, newTarget):
		'''
		Add a new constraint to the child
		newTarget: 
			is the new object that will act as parent
		object: 
			the child of the multiconstraints
		'''
		if not self.isActive():
			raise Exception("MultiConstraint.addMultiConstraint: multiConstraint is not active")
		
		object = self.networkNode.object.listConnections()[0]
		oldTargets = self.networkNode.targets.listConnections()
		
		if(oldTargets.count(newTarget) > 0):
			raise Exception('MultiConstraint.addMultiConstraintTarget: %s is already constrained to $s'%(newTarget, self.networkNode.object.listConnections()[0]))
		
		oldTargets.append(newTarget)
		
		self.removeMultiConstraint()
		self.create(oldTargets, object)		

	def getCurrentConstraint(self):
		"""
		gets the value of current constraint for given object
		return:
			an int from 0 - #numOfConstraints, #numOfConstraints == not constrainted to object
		"""
		if not self.isActive():
			raise Exception("MultiConstraint.getCurrentConstraint: multiConstraint is not active")
		
		constraint = self.networkNode.constraint.listConnections()[0]
		targetList = parentConstraint(constraint, q=1, targetList = 1)
		value = 0;
		found = 0;
		for target in targetList:
			if(found != 1):
				targetWeight = parentConstraint(target, constraint, q=1, weight = 1)
				found = targetWeight
				if(not found):
					value +=1
		return value	
				
			
		return self.networkNode.constraint.listConnections()[0]
			
	def getChild(self):
		'''
		returns the object that has the multiConstraint
		'''
		return self.networkNode.object.listConnections()[0]
		
	def getParents(self):
		'''
		return a list of parents of the multiConstraint
		'''
		return self.networkNode.targets.listConnections()
			
class Evil(MetaNode):
	def __init__(self,evilCurve, numJoints = 50, radius = 1, taper = 0, node = None):
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'Evil'):
					self.networkNode = node
				else:
					printError("Evil: node %s is not a Evil metaNode"%(node))
			else:
				printError("Evil: node %s doesn't exist"%(node))
			
		else:
			MetaNode.__init__(self, 'Evil', 1.0, 'evil growth')
			
			
			#error testing
			if not objExists(evilCurve):
				raise Exception("Evil.__init__: object doesn't exist, %s "%evilCurve)
			evilCurve = PyNode(evilCurve)
			
			#rebuild the curve
			makeCurveUniform(evilCurve)
			
			#createJoints
			joints = []
			select(cl = 1)
			for num in xrange(numJoints):
				j = joint()
				select(cl=1)
				joints.append(j)
			select(cl=1)
			
			#alignJoints to curve
			incPar = 1.0/(numJoints-1)
		
			pointOnCurves = []
			locs = []
			
			for j in joints[:-1]:
				j.orientJoint('xyz', zso=1, sao = 'zup')
			
			
			for inc in xrange(numJoints):
				j = joints[inc]
				poc ,loc = attachToCurve(evilCurve, j, incPar*inc, 1,1)
				pointOnCurves.append(poc)
				locs.append(loc)
				
			#draw override on joint color
			joints[0].overrideEnabled.set(1)
			joints[0].overrideColor.set(9)

			#createpoly
			orient = pointOnCurves[0].result.tangent.get()
			subdiv = 10
			poly, temp = polyCylinder(axis = orient,ch=1, o=1,r=radius,h=1,sx = subdiv, sc=0,cuv=3)
			delete(poly.f[:-1])
			
			#align poly to curve
			poly.centerPivots()
			alignPointOrient(joints[0], poly, 1,0)
			
			
			#extrude poly along curve
			polyExtrudeFacet(poly.f[0], ch=0, keepFacesTogether=1, pvx = 2.384185791e-007, pvy=0.5,pvz =3.576278687e-007,divisions=numJoints-1, twist=0, taper=taper, off=0,smoothingAngle=30 ,inputCurve=evilCurve)
			
			
			#unwrap UVs
			poc = PyNode(pointOnCurve(evilCurve, ch=1))
			incPar = 1.0/(numJoints-1)
			incOffset = 1.0/(numJoints-1)/2
			numFaces = poly.numFaces()
			for nf in xrange(numJoints-1):
				faces = []
				for sd in xrange(subdiv):
					faces.append(poly.f[((numFaces-2)/subdiv)*(sd)+2+nf])
				
				poc.parameter.set(incPar*nf+incOffset)
				loc1 = spaceLocator()
				loc1.translate.set(poc.result.position.get())
				trans = poc.result.position.get()
				
				poc.parameter.set(incPar*(nf+1)+incOffset)
				loc2 = spaceLocator()
				loc2.translate.set(poc.result.position.get())
				
				aimConstraint(loc2, loc1, w=1, mo=0, aimVector= [0, -1, 0], upVector= [0, 1, 0], worldUpType ="vector", worldUpVector=[ 0, 1, 0])
				
				rot = loc1.rotate.get()
				
				delete(loc1)
				delete(loc2)
				select(cl=1)
				map(lambda x: select(x, add=1), faces)
				polyCylindricalProjection( projectionCenter = trans,psu=360, smartFit = 1, rotate = rot)	
						
				
				
			delete(poc)
			select(poly, r=1)
			rt.DeleteHistory()
			select(cl=1)
			
			#bind poly to joints
			skinClust = skinCluster(poly, joints, sw=1)[0]

			#create anims
			anims = []
			
			#put first 2 cv in first anim
			select("%s.cv[%i]"%(evilCurve, 0))
			clust1, clustHandle1 = cluster()
			select("%s.cv[%i]"%(evilCurve, 1))
			clust2, clustHandle2 = cluster()
			cube, shape = polyCube()
			anims.append(cube)
			delete(parentConstraint(clustHandle2, clustHandle1, cube, w=1, mo=0))
			parent(clustHandle1, cube)
			parent(clustHandle2, cube)
			clustHandle1.hide()
			clustHandle2.hide()
			
			#rest of anims	
			for cv in xrange(evilCurve.numCVs()-2):
				cv = cv+2
				select("%s.cv[%i]"%(evilCurve, cv))
				clust, clustHandle = cluster()
				cube, shape = polyCube()
				anims.append(cube)
				alignPointOrient(clustHandle, cube, 1,1)
				parent(clustHandle, cube)
				clustHandle.hide()
			
			#zero out anims
			for anim in anims:
				makeIdentity(anim, apply=1, t=1, r=1, s=1, n=0)	
			
				
			#create Control obj
			
			controlGrp = group(empty = 1, n = 'evil_control')
			controlGrp.addAttr('evilGrow', min = 0, max =50, dv = 0, keyable =1)
			lockAndHideAttrs(controlGrp, ['tx', 'ty', 'tz', 'rx', 'ry', 'rz','sx', 'sy', 'sz','v'])
			attr = controlGrp.evilGrow
			
			#make setdriven keys		
			
			maximum = attr.getMax()
			if not maximum:
				maximum = 50
		
			incValue = maximum/numJoints
			
			for inc in xrange(numJoints):
				j = joints[inc]
				poc = pointOnCurves[inc]
				par = poc.parameter.get()
				
				#translate along curve
				attr.set(0)
				poc.parameter.set(0)
				setDrivenKeyframe(poc.parameter, cd = attr)
				
				attr.set(incValue*(inc))
				poc.parameter.set(par)
				setDrivenKeyframe(poc.parameter, cd = attr)
				
				#scales
				attr.set(incValue*inc)
				j.scale.set([0,0,0])
				setDrivenKeyframe(j.scale ,cd = attr)
				
				attr.set(maximum)
				j.scale.set(1,1,1)
				setDrivenKeyframe(j.scale, cd= attr)
				pointOnCurves.append(poc)
				
			#prepare the evil for attachment
			attachGrp = spaceLocator()
			attachGrp.rename('evil_attach_grp')
			poc, loc = attachToCurve(evilCurve, attachGrp, 0, 1,1)
			delete(poc, loc)
			#####orient down the x axis
			attachGrp.rotateY.set(attachGrp.rotateY.get() + 90)
			attachRotateControlGrp = group(empty = 1, n = 'evil_attach_rot_grp')
			alignPointOrient(attachGrp, attachRotateControlGrp, 1,1)
			parent(attachRotateControlGrp, attachGrp)
			makeIdentity(attachRotateControlGrp, apply=1, t=1, r=1, s=1, n=0)
				
			#groupings			
			animGrp = group(anims, n = 'evil_anims')
			locGrp = group(locs, n = 'locator_grp')
			jointGrp = group(joints, n = 'evil_joint_grp')
			dntGrp = group(locGrp, n = 'evil_DO_NOT_TOUCH')
			animGrp = group([controlGrp, animGrp],n = 'evil_anim_grp')
			evilGrp = group([attachGrp,dntGrp, evilCurve, jointGrp, poly], n = 'evil')
			parent(animGrp, attachRotateControlGrp)
			
			animGrp.hide()
			jointGrp.hide()
			dntGrp.hide()
			
			#attach all info to metaNodes

			connectToMeta(evilCurve, self.networkNode, 'curve')
			connectChainToMeta(joints, self.networkNode, 'joints')
			connectChainToMeta(anims, self.networkNode, 'anims')
			connectChainToMeta(pointOnCurves, self.networkNode, 'pocs')
			connectToMeta(controlGrp, self.networkNode, 'growGrp')
			connectToMeta(evilGrp, self.networkNode, 'mainGrp')
			self.networkNode.setAttr('growAttr', 'evilGrow', f=1)
			connectToMeta(animGrp, self.networkNode, 'animGrp')
			connectToMeta(poly, self.networkNode, 'mesh')
			connectToMeta(dntGrp, self.networkNode, 'dntGrp')
			self.networkNode.setAttr('radius', radius, f=1)
			self.networkNode.setAttr('taper', taper, f=1)
			
			#add attached information
			connectToMeta(attachGrp, self.networkNode, 'attachGrp')
			connectToMeta(attachRotateControlGrp, self.networkNode, 'rotateGrp')
			self.networkNode.setAttr('rotateAttr', 'rotateX' ,f=1)
			
			self.networkNode.addAttr('attachPoc', dt='string')
			self.networkNode.addAttr('attachLoc', dt='string')
			self.networkNode.setAttr('percentAttr', 'parameter', f=1)
			
			self.networkNode.addAttr('evilChildren', dt= 'string', multi=1)
			self.networkNode.setAttr('attached', 0, f=1)
			

	def toggleAnims(self):
		'''
		toggles showing and hiding the evil anims
		'''
		animGrp = self.networkNode.animGrp.listConnections()[0]
		if animGrp.v.get():
			animGrp.hide()
		else:
			animGrp.show()
			
	def hideAnims(self):
		'''
		hides the anims
		'''
		animGrp = self.networkNode.animGrp.listConnections()[0]
		animGrp.hide()
		
	def showAnims(self):
		'''
		shows the anims
		'''
		animGrp = self.networkNode.animGrp.listConnections()[0]
		animGrp.show()
		
		
		
	def attachEvil(self, other, percent = .5):
		'''
		attached the other evil to this evil at the percent given
		other:
			other evil to attach to self
		percent:
			where along the curve to add evil [0,1]
		return True if connection was successful, else False
		'''
		#error test
		if other == self:
			raise Exception("can't connect self as parent and child")
		if percent > 1 or percent < 0:
			raise Exception("percent needs to be between 0 and 1")
		if not isMetaNodeOfType(other.networkNode, 'Evil'):
			raise Exception("other evil object isn't of class Evil")
		if other.networkNode in self.listEvilParents():	
			raise Exception("other evil is a parent of this evil, parenting would cause loop")
		#don't attach if already attached
		if other.isAttached():
			return False
			
		attachGrp = other.getAttachGrp()
		poc, loc = attachToCurve(self.getCurve(), attachGrp, percent,1,1)
		
		#meta Connections
		connectToMeta(poc, other.networkNode, 'attachPoc')
		connectToMeta(loc, other.networkNode, 'attachLoc')
		parent(loc, other.networkNode.dntGrp.listConnections()[0])
		connectToMeta(other.networkNode, self.networkNode, 'evilChildren')
	
		other.networkNode.attached.set(1)
		return True
		
	def detach(self):
		'''
		detach self from all other evils
		'''
		if not self.isAttached():
			raise Exception("Evil.detach: This Evil is already detached")
		poc = self.networkNode.attachPoc.listConnections()[0]
		loc = self.networkNode.attachLoc.listConnections()[0]
		delete(poc)
		delete(loc)
		self.networkNode.metaParent.disconnect()
		self.networkNode.attached.set(0)

	def listEvilParents(self):
		"""
		returns a list of all parents and parent's parent etc of this evil
		return:
			[parent, parent, ...]
		"""
		parents = []
		currentPar = None
		try:
			currentPar = self.networkNode.metaParent.listConnections()[0]
		except:
			pass
		if currentPar:
			parents.append(currentPar)
		while currentPar:
			par = None
			try:
				par = currentPar.networkNode.metaParent.listConnections()[0]
			except:
				pass
			if par:
				parents.append(par)
			currentPar = par
		return parents
		
	def getAttachGrp(self):
		'''
		returns the group to attach To
		'''
		return self.networkNode.attachGrp.listConnections()[0]
		
	def isAttached(self):
		'''
		returns whether this evil is attached to something else
		'''
		return self.networkNode.attached.get()
		
	def getCurve(self):
		'''
		returns the curve controling the evil
		'''
		return self.networkNode.curve.listConnections()[0]
		
	def listAnims(self):
		'''
		return a list of the anims that control curve
		'''
		return self.networkNode.anims.listConnections()
		
	def keyAnims(self):
		'''
		keyframes all the anims at their current position at the current time
		'''
		for anim in self.listAnims():
			setKeyframe(anim)
	
	def randomizeAnims(self, value):
		'''
		randomizes all anims except the start anim by offseting translation by the given value
		value:
			how much to offset by
		'''		
		import random
		attrs = ['tx', 'ty', 'tz']
		for anim in self.listAnims()[1:]:
			for attr in attrs:
				pos = random.choice([-1,1])
				at = anim.attr(attr)
				at.set(at.get() + (random.random()* value*pos))
		
	
	def delete(self):
		'''
		removes the everything related to the evil except the curve it was created from
		return:
			the curve it was created from
		'''
		
		#delete point On Curves
		pocs = self.networkNode.pocs.listConnections()
		delete(pocs)
		
		#unparent Curve
		evilCurve = self.networkNode.curve.listConnections()[0]
		parent(evilCurve, world = 1)
		evilCurve2 = duplicate(evilCurve)[0]
		evilChildren = evilCurve2.getChildren()
		for obj in evilChildren:
			if obj != evilCurve2.getShape():
				delete(obj)
		delete(evilCurve)
		
		
		#delete maingrp
		mGrp = self.networkNode.mainGrp.listConnections()[0]
		delete(mGrp)
		
		#delete metaNode
		try:
			delete(self.networkNode)
		except:
			pass
			
		#return
		return evilCurve2
		
	def recreate(self, numJoints = None, radius = None, taper = None):
		'''
		recreate evil with new inputs
		'''
		if numJoints == None:
			numJoints = len(self.networkNode.joints.listConnections())
		if radius == None:
			radius = self.networkNode.radius.get()
		if taper == None:
			taper = self.networkNode.taper.get()
			
		#get connected evil and percent
		percent = None
		if self.isAttached():
			percent = self.getPercentAttr().get()
			evilPar = self.networkNode.metaParent.listConnections()[0]
			ep = None
			if isMetaNodeOfType(evilPar,'Evil'):
				ep = evilPar
		
		#list children for re attach children nodes		
		allChildren = self.listEvilChildren()
		allChildren = map(lambda x: Evil('', node = x.name()), allChildren)		
		childPer = {}
		for child in allChildren:
			childPer[child] = child.getPercentAttr().get()
			child.detach()	
			
			
		ecurve = self.delete()
		newEvil = Evil(ecurve, numJoints = int(numJoints), radius = radius, taper = taper)
		
		for child in allChildren:
			newEvil.attachEvil(child, childPer[child])
		
		
		if not percent == None:
			Evil('', node = ep).attachEvil(newEvil, percent)
		
			
		return newEvil
		
	def getGrowAttr(self):
		'''
		gets the attribute that causes the evil to grow
		return:
			the attribute object
		'''
		growGrp = self.networkNode.growGrp.listConnections()[0]
		attr = self.networkNode.growAttr.get()
		return PyNode(growGrp.attr(attr))
		
	def getRotateAttr(self):
		'''
		gets the attribute that causes the evil to rotate around parent
		return:
			the attribute if isAttached to another evil, else None	
		'''
		if not self.isAttached():
			return None
		rotateGrp = self.networkNode.rotateGrp.listConnections()[0]
		attr = self.networkNode.rotateAttr.get()
		return PyNode(rotateGrp.attr(attr))
		
	def getPercentAttr(self):
		'''
		gets the attribute that causes the evil to move along parent
		return:
			the attribute, if isAttached to another evil, else None	
		'''
		if not self.isAttached():
			return None
		percentGrp = self.networkNode.attachPoc.listConnections()[0]
		attr = self.networkNode.percentAttr.get()
		return PyNode(percentGrp.attr(attr))
	
	def listEvilChildren(self):
		'''
		returns a list of all the Evil Children directly attached to this Evil
		'''
		return self.networkNode.evilChildren.listConnections()
		
	def recreateDownChain(self, startTime, endTime):
		'''
		generates new evil down the chain
		'''
		
		
		#new start Time keying
		currentTime(startTime)
		self.getGrowAttr().set(0)
		setKeyframe(self.getGrowAttr())
		self.keyAnims()
		
		
		#new end time keying
		currentTime(endTime)
		self.getGrowAttr().set(50)
		setKeyframe(self.getGrowAttr())
		self.randomizeAnims(self.networkNode.radius.get()*2)
		self.keyAnims()
		
		for child in self.listEvilChildren():
			child = Evil('', node = child)
			#get new values
			ratio = child.getPercentAttr().get()
			newRadius = (self.networkNode.radius.get() - ((1-self.networkNode.taper.get())*self.networkNode.radius.get())*ratio)
			offsetTime = endTime -startTime
			newStartTime = offsetTime * ratio +startTime
			newEndTime = offsetTime + newStartTime
			
			#recreate child curve
			child = child.recreate(radius = newRadius)
			child.recreateDownChain(newStartTime, newEndTime)
		
		currentTime(startTime)

class VillageHouse(MetaNode):
	def __init__(self, node = None):
		'''
		creates a house based on random points
		'''
		if node:
			if objExists(node):
				node = PyNode(node)
				if( isMetaNode(node) and node.metaType.get() == 'VillageHouse'):
					self.networkNode = node
				else:
					printError("VillageHouse: node %s is not a VillageHouse metaNode"%(node))
			else:
				printError("VillageHouse: node %s doesn't exist"%(node))
		else:
			MetaNode.__init__( self, "VillageHouse", 1.0, "a village house")
			#add some variables to the meta
			self.networkNode.addAttr('houseParts', dt = 'string', m=1)
			self.networkNode.setAttr("housePartsDirectory", "C:/Users/Jason/LampLighter/LL project/scenes/models/house/for import/low", f=1)
			
			#door
			hasRightDoor = random.random() < .5
			hasLeftDoor = 1-hasRightDoor
			self.networkNode.setAttr("hasRightDoor", hasRightDoor, f=1)
			self.networkNode.setAttr("hasLeftDoor", hasLeftDoor, f=1)
			
			#trim
			hasTrim = random.random() < .75
			hasFlattenedTrim = 0 #if false, has ribbed Trim
			hasTrimBase = 0
			if hasTrim:
				hasFlattenedTrim = random.random() < .5
				hasTrimBase = random.random() < .8			
			#meta trim
			self.networkNode.setAttr("hasTrim", hasTrim, f=1)
			self.networkNode.setAttr("hasFlattenedTrim", hasFlattenedTrim, f=1)
			self.networkNode.setAttr("hasTrimBase", hasTrimBase, f=1)
				
			#side accent trim 
			hasSideAccentTrim = random.random() < .5
			hasSideAccentTrimCenter = 0
			hasSideAccentTrimCorners = 0
			if hasSideAccentTrim:
				hasSideAccentCorners = random.random() < .75
				if hasSideAccentCorners:
					hasSideAccentTrimCenter = random.random() < .6
				else:
					hasSideAccentTrimCenter = 1
			hasBackAccentTrim = random.random() < .25
			hasBackAccentTrimCenter = 0
			hasBackAccentTrimCorners = 0
			if hasBackAccentTrim:
				hasBackAccentCorners = random.random() < .75
				if hasBackAccentCorners:
					hasBackAccentTrimCenter = .6
				else:
					hasBackAccentTrimCenter = 1
			hasFrontAccentTrim = random.random() < .1
			hasFrontAccentTrimCenter = 0
			hasFrontAccentTrimCorners = 0
			if hasFrontAccentTrim:
				hasFrontAccentTrimCorners = random.random() < .75
				if hasFrontAccentTrimCorners:
					hasFrontAccentTrimCenter = .6
				else:
					hasFrontAccentTrimCenter = 1	
			#side accent trim meta
			self.networkNode.setAttr("hasSideAccentTrim", hasSideAccentTrim, f=1)
			self.networkNode.setAttr("hasSideAccentTrimCenter", hasSideAccentTrimCenter, f=1)
			self.networkNode.setAttr("hasSideAccentTrimCorners", hasSideAccentTrimCorners, f=1)
			self.networkNode.setAttr("hasBackAccentTrim", hasBackAccentTrim, f=1)
			self.networkNode.setAttr("hasBackAccentTrimCenter", hasBackAccentTrimCenter, f=1)
			self.networkNode.setAttr("hasBackAccentTrimCorners", hasBackAccentTrimCorners, f=1)
			self.networkNode.setAttr("hasFrontAccentTrim", hasFrontAccentTrim, f=1)
			self.networkNode.setAttr("hasFrontAccentTrimCenter", hasFrontAccentTrimCenter, f=1)
			self.networkNode.setAttr("hasFrontAccentTrimCorners", hasFrontAccentTrimCorners, f=1)
			
			#side addition
			hasLeftSideAddition = random.random() < .5 #has side addition on both sides on left
			hasRightSideAddition = random.random() < .5 #has side addition on both sides on right
			hasBackAddition = random.random() < .3
			
			#side addition meta
			self.networkNode.setAttr("hasLeftSideAddition", hasLeftSideAddition, f=1)
			self.networkNode.setAttr("hasRightSideAddition", hasRightSideAddition, f=1)
			self.networkNode.setAttr("hasBackAddition", hasBackAddition, f=1)
			
			#roof accent arc/awning		
			hasRoofAccentLeft = random.random() < .75
			hasRoofAccentRight = random.random() < .75
			hasLeftAwning = 0 #if not should have arcs on left
			hasRightAwning = 0 # if not should have arcs on right
			if hasRoofAccentLeft:
				hasLeftAwning = random.random() < .5
			if hasRoofAccentRight:
				hasRightAwning = random.random() < .5
			hasRoofFrontAccent = random.random() < .8
			hasRoofBackAccent = random.random() < .6
			hasFrontAwning = 0
			hasBackAwning = 0
			if hasRoofFrontAccent:
				hasFrontAwning = random.random() < .5
			if hasRoofBackAccent:
				hasBackAwning = random.random() < .5	
			
			#roof accent arc/awning meta
			self.networkNode.setAttr("hasRoofAccentLeft", hasRoofAccentLeft, f=1)
			self.networkNode.setAttr("hasRoofAccentRight", hasRoofAccentRight, f=1)
			self.networkNode.setAttr("hasLeftAwning", hasLeftAwning, f=1)
			self.networkNode.setAttr("hasRightAwning", hasRightAwning, f=1)
			self.networkNode.setAttr("hasRoofFrontAccent", hasRoofFrontAccent, f=1)
			self.networkNode.setAttr("hasRoofBackAccent", hasRoofBackAccent, f=1)
			self.networkNode.setAttr("hasFrontAwning", hasFrontAwning, f=1)
			self.networkNode.setAttr("hasBackAwning", hasBackAwning, f=1)
			
				
			#roof cylinder/window
			hasFrontRoofCylinder = random.random() < .2
			hasRightRoofCylinder = 0
			hasLeftRoofCylinder = 0
			hasBackRoofCylinder = 0
			if not (hasRightSideAddition or hasLeftSideAddition):
				hasRightRoofCylinder = random.random() < .2
			if not (hasRightSideAddition or hasLeftSideAddition):
				hasLeftRoofCylinder = random.random() < .2
			if not hasBackAddition:
				hasBackRoofCylinder = random.random() < .2
			hasFrontWindow = 0
			hasBackWindow = 0
			hasLeftWindow = 0
			hasRightWindow = 0	
			if hasBackRoofCylinder:
				hasBackWindow = random.random() < .2
			if hasFrontRoofCylinder:
				hasFrontWindow = random.random() < .2
			if hasLeftRoofCylinder:
				hasLeftWindow = random.random() < .2
			if hasRightRoofCylinder:
				hasRightWindow = random.random() < .2
			#roof cylinder/window meta
			self.networkNode.setAttr("hasFrontWindow",hasFrontWindow,f=1)
			self.networkNode.setAttr("hasBackWindow",hasBackWindow,f=1)
			self.networkNode.setAttr("hasRightWindow",hasRightWindow,f=1)
			self.networkNode.setAttr("hasLeftWindow",hasLeftWindow,f=1)
			self.networkNode.setAttr("hasFrontRoofCylinder",hasFrontRoofCylinder,f=1)
			self.networkNode.setAttr("hasBackRoofCylinder",hasBackRoofCylinder,f=1)
			self.networkNode.setAttr("hasRightRoofCylinder", hasRightRoofCylinder,f=1)
			self.networkNode.setAttr("hasLeftRoofCylinder",hasLeftRoofCylinder,f=1)	
					
			#put together the house	
			self.putTogether()
		
	def putTogether(self):
		'''
		imports all the house pieces and to create house
		if house already put together, deletes all then puts together again
		'''
		oldHouse = None
		try:
			oldHouse = self.networkNode.house.listConnections()
		except:
			pass
		oldHouseTrans = None
		oldHouseRot = None
		oldHouseScale = None
		loc = spaceLocator()
		if oldHouse:
			#connect a temp locator, so deletion doesn't delete self.networkNode
			connectToMeta(loc, self.networkNode, 'house')
			oldHouseTrans = oldHouse[0].translate.get()
			oldHouseRot = oldHouse[0].rotate.get()
			oldHouseScale = oldHouse[0].scale.get()
			delete(oldHouse[0])
		
		#import the house base
		houseBase = self.importHousePart('main_house')
		connectToMeta(houseBase, self.networkNode, 'house')
		
		#delete temp locator
		delete(loc)
		
		#label with name
		houseBase.attr("type").set(18)	
		houseBase.otherType.set(houseBase.name())
		
		#addRoof
		roof = self.importHousePart('roof')
		self.attachTo(roof)
		
		#add roof corners
		bumps = self.importHousePart("roof_corner_bump")
		self.attachTo(bumps)
		
		#door
		hasRightDoor = self.networkNode.hasRightDoor.get()
		hasLeftDoor = self.networkNode.hasLeftDoor.get()
		if hasRightDoor:
			rdoor = self.importHousePart("right_door")
			self.attachTo(rdoor)
		if hasLeftDoor:
			ldoor = self.importHousePart("left_door")
			self.attachTo(ldoor)
		
		#add trim to house
		hasTrim = self.networkNode.hasTrim.get()
		hasFlattenedTrim = self.networkNode.hasFlattenedTrim.get()
		hasTrimBase = self.networkNode.hasTrimBase.get()
		if hasTrim:
			if hasFlattenedTrim:
				trim = self.importHousePart("flattened_trim")
				self.attachTo(trim)
			else:
				trim = self.importHousePart("ribbed_trim")
				self.attachTo(trim)
		if hasTrimBase:
			trimBase = self.importHousePart("trim_base")
			self.attachTo(trimBase)
		
		#side accent trim meta
		#sideAccentTrim = self.networkNode.hasSideAccentTrim.get()
		hasSideAccentTrimCenter = self.networkNode.hasSideAccentTrimCenter.get()
		hasSideAccentTrimCorners = self.networkNode.hasSideAccentTrimCorners.get()
		#hasBackAccentTrim = self.networkNode.hasBackAccentTrim.get()
		hasBackAccentTrimCenter = self.networkNode.hasBackAccentTrimCenter.get()
		hasBackAccentTrimCorners = self.networkNode.hasBackAccentTrimCorners.get()
		#hasFrontAccentTrim = self.networkNode.hasFrontAccentTrim.get()
		hasFrontAccentTrimCenter = self.networkNode.hasFrontAccentTrimCenter.get()
		hasFrontAccentTrimCorners = self.networkNode.hasFrontAccentTrimCorners.get()
		if hasSideAccentTrimCenter:
			sideAccentTrim = self.importHousePart("side_accent_trim_center")
			self.attachTo(sideAccentTrim,90)
			sideAccentTrim = self.importHousePart("side_accent_trim_center")
			self.attachTo(sideAccentTrim,270)
		if hasSideAccentTrimCorners:
			sideAccentTrim = self.importHousePart("side_accent_trim_corners")
			self.attachTo(sideAccentTrim,90)
			sideAccentTrim = self.importHousePart("side_accent_trim_corners")
			self.attachTo(sideAccentTrim,270)
		if hasBackAccentTrimCorners:
			sideAccentTrim = self.importHousePart("side_accent_trim_corners")
			self.attachTo(sideAccentTrim)
		if hasBackAccentTrimCenter:
			sideAccentTrim = self.importHousePart("side_accent_trim_center")
			self.attachTo(sideAccentTrim,180)
		if hasFrontAccentTrimCorners:
			sideAccentTrim = self.importHousePart("side_accent_trim_corners")
			self.attachTo(sideAccentTrim)
		if hasFrontAccentTrimCenter:
			sideAccentTrim = self.importHousePart("side_accent_trim_center")
			self.attachTo(sideAccentTrim)
			
		
		#add additions
		hasLeftSideAddition = self.networkNode.hasLeftSideAddition.get()
		hasRightSideAddition = self.networkNode.hasRightSideAddition.get()
		hasBackAddition = self.networkNode.hasBackAddition.get()
		if hasLeftSideAddition:
			rightAddition = self.importHousePart("side_addition_right")
			leftAddition = self.importHousePart("side_addition_left")
			self.attachTo(rightAddition,90)
			self.attachTo(leftAddition,270)
		if hasRightSideAddition:
			rightAddition = self.importHousePart("side_addition_left")
			leftAddition = self.importHousePart("side_addition_right")
			self.attachTo(rightAddition,90)
			self.attachTo(leftAddition,270)
		if hasBackAddition:
			rightAddition = self.importHousePart("side_addition_right")
			leftAddition = self.importHousePart("side_addition_left")
			self.attachTo(rightAddition,180)
			self.attachTo(leftAddition,180)
		
		
			
		#add roof accent arc/awning
		hasRoofAccentLeft = self.networkNode.hasRoofAccentLeft.get()
		hasRoofAccentRight = self.networkNode.hasRoofAccentRight.get()
		hasLeftAwning = self.networkNode.hasLeftAwning.get()
		hasRightAwning = self.networkNode.hasRightAwning.get()
		hasRoofFrontAccent = self.networkNode.hasRoofFrontAccent.get()
		hasRoofBackAccent = self.networkNode.hasRoofBackAccent.get()
		hasFrontAwning = self.networkNode.hasFrontAwning.get()
		hasBackAwning = self.networkNode.hasBackAwning.get()	
		if hasRoofAccentLeft:
			if hasLeftAwning:
				awning = self.importHousePart("roof_accent_awning")
				self.attachTo(awning,270)
			else:
				arc = self.importHousePart("roof_accent_arc")
				self.attachTo(arc, 270)
		if hasRoofAccentRight:
			if hasRightAwning:
				awning = self.importHousePart("roof_accent_awning")
				self.attachTo(awning,90)
			else:
				arc = self.importHousePart("roof_accent_arc")
				self.attachTo(arc, 90)
		if hasRoofFrontAccent:
			if hasFrontAwning:
				awning = self.importHousePart("roof_accent_awning")
				self.attachTo(awning)
			else:
				arc = self.importHousePart("roof_accent_arc")
				self.attachTo(arc)
		if hasRoofBackAccent:
			if hasBackAwning:
				awning = self.importHousePart("roof_accent_awning")
				self.attachTo(awning,180)
			else:
				arc = self.importHousePart("roof_accent_arc")
				self.attachTo(arc, 180)
		
		
		
		#add windows/cylinders
		hasFrontWindow = self.networkNode.hasFrontWindow.get()
		hasBackWindow = self.networkNode.hasBackWindow.get()
		hasRightWindow = self.networkNode.hasRightWindow.get()
		hasLeftWindow = self.networkNode.hasLeftWindow.get()
		hasFrontRoofCylinder = self.networkNode.hasFrontRoofCylinder.get()
		hasBackRoofCylinder = self.networkNode.hasBackRoofCylinder.get()
		hasRightRoofCylinder = self.networkNode.hasRightRoofCylinder.get()
		hasLeftRoofCylinder = self.networkNode.hasLeftRoofCylinder.get()	
		if hasFrontWindow:
			houseWindow = self.importHousePart("window")
			self.attachTo(houseWindow)
		if hasBackWindow:
			houseWindow = self.importHousePart("window")
			self.attachTo(houseWindow,180)
		if hasRightWindow:
			houseWindow = self.importHousePart("window")
			self.attachTo(houseWindow,90)
		if hasLeftWindow:
			houseWindow = self.importHousePart("window")
			self.attachTo(houseWindow,270)
		if hasFrontRoofCylinder:
			roofCyl = self.importHousePart("roof_cylinder")
			self.attachTo(roofCyl)
		if hasBackRoofCylinder:
			roofCyl = self.importHousePart("roof_cylinder")
			self.attachTo(roofCyl,180)
		if hasRightRoofCylinder:
			roofCyl = self.importHousePart("roof_cylinder")
			self.attachTo(roofCyl,90)
		if hasLeftRoofCylinder:
			roofCyl = self.importHousePart("roof_cylinder")
			self.attachTo(roofCyl,270)
		
		
		
		if oldHouse:
			print str(oldHouse) + "!!!"
			houseBase.translate.set(oldHouseTrans)
			houseBase.rotate.set(oldHouseRot)
			houseBase.scale.set(oldHouseScale)
			
			
			
	def importHousePart(self, obj):
		'''
		imports object into scene from the house parts directory
		obj:
			the file name of the obj in the houseparts directory
		return:
			the obj that was imported
		'''
		if obj.endswith(".ma"):
			obj = obj.replace(".ma", "")
		all = ls(dag = 1, type = 'joint')
		importFile(self.networkNode.housePartsDirectory.get() + "/" + obj + ".ma", defaultNamespace = 1)
		new =  ls(dag =1, type = 'joint')
		for obj in new:
			if not obj in all:
				return obj
				
	def attachTo(self, obj, rot=0):
		'''
		attaches the object to the house
		obj:
			the object to attach
		rotate:
			the amount to rotate around Y, to match possible sides
		'''
		house = self.networkNode.house.listConnections()[0]
		obj = PyNode(obj)
		obj.scale.set(house.scale.get())
		alignPointOrient(house, obj, 1,1)
		rotate(obj, [0,rot,0],os=1, r=1)
		parent(obj, house)
		obj.inverseScale.disconnect()
		connectToMeta(obj, self.networkNode, "houseParts")
	
	def alignToObj(self, obj, point =1, orient = 1):
		'''
		aligns the house to the given object
		obj:
			object to align to
		point:
			should align by point
		orient:
			should aling by rotation
		'''
		if not objExists(obj):
			raise Exception("VillageHouse.alignToObj: object given,%s , doesn't exist"%obj)
		obj = PyNode(obj)
		house = self.networkNode.house.listConnections()[0]
		alignPointOrient(obj, house, point, orient)
		
	
		
	
'''
THINGS TO POSSIBLY CHANGE FOR FURTHER DEVELOPMENT

connectToMeta and connectChainToMeta should look like      MetaObj.connectTo(obj, attrName)
	makes for a more fundamentally object oriented programming

each chain should be a meta structure, and have index, name, etc

should be able to create ik and fk chains as a method
	
metaNodes can be created by passing in attributes and by existing nodes, by metaNodes have to be passed many attrs to create by node
possible to create by factory,  MetaObj().create(....) and MetaObj().node(...) 
	separates the object to be created by multiple means easier and more efficent
	also allows possible calls like Meta().isMetaNode(obj), for making places for meta outside functions
	

possibly get side and bodypart from joint labels
	pro, less input into creation
	con, component can possible be labels the same if both joints have same label, (if based on start joint l_leg and l_thigh could have same name) 
	
	
possible interface classes for metaIK, metaFK, and MetaDyn for methods to help with .isIK, .getIKAnim and such

make anim a class which adds the node attrs\fbik, creates shapes, swaps shapes, etc.
'''
		
